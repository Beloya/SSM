# SQL Manager for MySQL 5.4.3.43929
# ---------------------------------------
# Host     : 119.29.112.39
# Port     : 3306
# Database : MyBlog


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

SET FOREIGN_KEY_CHECKS=0;

DROP DATABASE IF EXISTS `MyBlog`;

CREATE DATABASE `MyBlog`
    CHARACTER SET 'latin1'
    COLLATE 'latin1_swedish_ci';

USE `MyBlog`;

#
# Dropping database objects
#

DROP TABLE IF EXISTS `users`;
DROP TABLE IF EXISTS `type`;
DROP TABLE IF EXISTS `roles_permissions`;
DROP TABLE IF EXISTS `roles`;
DROP TABLE IF EXISTS `message_board`;
DROP TABLE IF EXISTS `message`;
DROP TABLE IF EXISTS `flag`;
DROP TABLE IF EXISTS `blog`;
DROP TABLE IF EXISTS `archivesvisibility`;
DROP TABLE IF EXISTS `archivescommit`;
DROP TABLE IF EXISTS `archives`;
DROP TABLE IF EXISTS `archiveflag`;

#
# Structure for the `archiveflag` table : 
#

CREATE TABLE `archiveflag` (
  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `AID` INTEGER(11) NOT NULL COMMENT '文章ID',
  `FID` INTEGER(11) NOT NULL COMMENT '标签ID',
  `REVISION` INTEGER(11) DEFAULT NULL COMMENT '乐观锁',
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建人',
  `CREATED_TIME` DATETIME NOT NULL COMMENT '创建时间',
  `UPDATED_BY` INTEGER(11) DEFAULT NULL COMMENT '更新人',
  `UPDATED_TIME` DATETIME DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY USING BTREE (`ID`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=45 AVG_ROW_LENGTH=2340 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `archives` table : 
#

CREATE TABLE `archives` (
  `AID` INTEGER(11) NOT NULL AUTO_INCREMENT COMMENT '主键;自增',
  `Title` VARCHAR(100) COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `context` LONGTEXT COLLATE utf8mb4_general_ci NOT NULL COMMENT '内容',
  `Type` INTEGER(11) NOT NULL COMMENT '类型',
  `CREATED_BY` VARCHAR(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建人',
  `CREATED_TIME` DATETIME NOT NULL COMMENT '创建时间',
  `UPDATED_BY` VARCHAR(32) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人',
  `UPDATED_TIME` DATETIME DEFAULT NULL COMMENT '更新时间',
  `Status` INTEGER(11) NOT NULL COMMENT '状态;1审核||0正常||-1失效',
  `ReadCount` INTEGER(11) NOT NULL DEFAULT 0 COMMENT '阅读数',
  `Flag` INTEGER(11) DEFAULT 0 COMMENT '标签;外键',
  `VID` INTEGER(11) NOT NULL COMMENT '可见性;外键',
  PRIMARY KEY USING BTREE (`AID`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=36 AVG_ROW_LENGTH=32768 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `archivescommit` table : 
#

CREATE TABLE `archivescommit` (
  `CID` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `Context` LONGTEXT COLLATE utf8mb4_general_ci NOT NULL,
  `PID` INTEGER(11) DEFAULT NULL,
  `REVISION` INTEGER(11) DEFAULT NULL,
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `CREATED_TIME` DATETIME NOT NULL,
  `UPDATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `UPDATED_TIME` DATETIME DEFAULT NULL,
  `Status` INTEGER(11) NOT NULL,
  `AID` INTEGER(11) NOT NULL,
  `TYPE` INTEGER(11) NOT NULL DEFAULT 0,
  `Name` VARCHAR(55) COLLATE utf8mb4_general_ci DEFAULT NULL,
  PRIMARY KEY USING BTREE (`CID`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=76 AVG_ROW_LENGTH=1365 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `archivesvisibility` table : 
#

CREATE TABLE `archivesvisibility` (
  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `Vdescribe` VARCHAR(100) COLLATE utf8mb4_general_ci NOT NULL,
  `REVISION` INTEGER(11) DEFAULT NULL,
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `CREATED_TIME` DATETIME NOT NULL,
  `UPDATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `UPDATED_TIME` DATETIME DEFAULT NULL,
  `Status` INTEGER(11) NOT NULL,
  PRIMARY KEY USING BTREE (`ID`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=3 AVG_ROW_LENGTH=8192 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `blog` table : 
#

CREATE TABLE `blog` (
  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `BlogName` VARCHAR(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客名',
  `REVISION` INTEGER(11) DEFAULT NULL COMMENT '乐观锁',
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建人',
  `CREATED_TIME` DATETIME NOT NULL COMMENT '创建时间',
  `UPDATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人',
  `UPDATED_TIME` DATETIME DEFAULT NULL COMMENT '更新时间',
  `Title` VARCHAR(250) COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `MessageSay` LONGTEXT COLLATE utf8mb4_general_ci,
  `HeaderSkin` VARCHAR(100) COLLATE utf8mb4_general_ci DEFAULT NULL,
  PRIMARY KEY USING BTREE (`ID`) COMMENT '',
  UNIQUE INDEX `CREATED_BY` USING BTREE (`CREATED_BY`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=2 AVG_ROW_LENGTH=16384 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `flag` table : 
#

CREATE TABLE `flag` (
  `FID` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `Fdescribe` VARCHAR(25) COLLATE utf8mb4_general_ci NOT NULL,
  `REVISION` INTEGER(11) DEFAULT NULL,
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `CREATED_TIME` DATETIME NOT NULL,
  `UPDATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `UPDATED_TIME` DATETIME DEFAULT NULL,
  `Status` INTEGER(11) NOT NULL DEFAULT 0,
  PRIMARY KEY USING BTREE (`FID`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=16 AVG_ROW_LENGTH=5461 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `message` table : 
#

CREATE TABLE `message` (
  `ID` INTEGER(11) NOT NULL COMMENT '主键;自增',
  `Context` LONGTEXT COLLATE utf8mb4_general_ci COMMENT '内容',
  `Link` VARCHAR(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '链接',
  `REVISION` INTEGER(11) DEFAULT NULL COMMENT '乐观锁',
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建人',
  `CREATED_TIME` DATETIME NOT NULL COMMENT '创建时间',
  `UPDATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '更新人',
  `UPDATED_TIME` DATETIME DEFAULT NULL COMMENT '更新时间',
  `Status` INTEGER(11) NOT NULL COMMENT '状态;1审核||0正常||-1失效',
  PRIMARY KEY USING BTREE (`ID`) COMMENT ''
)ENGINE=InnoDB
ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `message_board` table : 
#

CREATE TABLE `message_board` (
  `MBID` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `Context` LONGTEXT COLLATE utf8mb4_general_ci NOT NULL,
  `REVISION` INTEGER(11) DEFAULT NULL,
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `CREATED_TIME` DATETIME NOT NULL,
  `UPDATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `UPDATED_TIME` DATETIME DEFAULT NULL,
  `Status` INTEGER(11) NOT NULL,
  `Name` VARCHAR(45) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `MBPID` INTEGER(11) DEFAULT NULL,
  PRIMARY KEY USING BTREE (`MBID`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=4 AVG_ROW_LENGTH=5461 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `roles` table : 
#

CREATE TABLE `roles` (
  `R_Id` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `RoleName` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `description` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `CreatorId` INTEGER(11) DEFAULT NULL,
  `CreateDate` DATETIME NOT NULL,
  `DataLevel` TINYINT(4) NOT NULL DEFAULT 0,
  PRIMARY KEY USING BTREE (`R_Id`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=5 AVG_ROW_LENGTH=5461 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `roles_permissions` table : 
#

CREATE TABLE `roles_permissions` (
  `RP_Id` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `RId` INTEGER(11) NOT NULL,
  `permission` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `CreatorId` INTEGER(11) DEFAULT NULL,
  `CreateDate` DATETIME NOT NULL,
  `DataLevel` TINYINT(4) DEFAULT 0,
  PRIMARY KEY USING BTREE (`RP_Id`) COMMENT '',
   INDEX `PRid_idx` USING BTREE (`RId`) COMMENT '',
  CONSTRAINT `roles_permissions_fk1` FOREIGN KEY (`RId`) REFERENCES `roles` (`R_Id`)
)ENGINE=InnoDB
AUTO_INCREMENT=11 AVG_ROW_LENGTH=3276 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `type` table : 
#

CREATE TABLE `type` (
  `TID` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `Tdescribe` VARCHAR(25) COLLATE utf8mb4_general_ci NOT NULL,
  `REVISION` INTEGER(11) DEFAULT NULL,
  `CREATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `CREATED_TIME` DATETIME NOT NULL,
  `UPDATED_BY` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `UPDATED_TIME` DATETIME DEFAULT NULL,
  `Status` INTEGER(11) NOT NULL DEFAULT 0 COMMENT '状态;1审核||0正常||-1失效',
  PRIMARY KEY USING BTREE (`TID`) COMMENT ''
)ENGINE=InnoDB
AUTO_INCREMENT=11 AVG_ROW_LENGTH=5461 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Structure for the `users` table : 
#

CREATE TABLE `users` (
  `U_Id` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `Rid` INTEGER(11) NOT NULL,
  `userName` VARCHAR(45) COLLATE utf8mb4_bin DEFAULT NULL,
  `passWord` VARCHAR(50) COLLATE utf8mb4_general_ci NOT NULL,
  `CreatorId` INTEGER(11) DEFAULT NULL,
  `CreateDate` DATETIME NOT NULL,
  `DataLevel` TINYINT(4) NOT NULL DEFAULT 0,
  `Email` VARCHAR(50) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `Sex` TINYINT(4) NOT NULL,
  `locked` TINYINT(1) NOT NULL,
  `UserImg` VARCHAR(100) COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY USING BTREE (`U_Id`) COMMENT '',
  UNIQUE INDEX `userName_UNIQUE` USING BTREE (`userName`) COMMENT '',
   INDEX `Rid_idx` USING BTREE (`Rid`) COMMENT '',
  CONSTRAINT `users_fk1` FOREIGN KEY (`Rid`) REFERENCES `roles` (`R_Id`)
)ENGINE=InnoDB
AUTO_INCREMENT=7 AVG_ROW_LENGTH=8192 ROW_FORMAT=DYNAMIC CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_general_ci'
COMMENT=''
;

#
# Data for the `archiveflag` table  (LIMIT -455,500)
#

INSERT INTO `archiveflag` (`ID`, `AID`, `FID`, `REVISION`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`) VALUES

  (1,1,1,NULL,'Beloya','2018-07-07 01:51:54',NULL,NULL),
  (2,1,2,NULL,'Beloya','2018-07-07 01:51:54',NULL,NULL),
  (3,1,1,NULL,'Beloya','2018-07-07 07:29:29',NULL,NULL),
  (4,1,2,NULL,'Beloya','2018-07-07 07:29:29',NULL,NULL),
  (5,1,1,NULL,'Beloya','2018-07-07 07:32:20',NULL,NULL),
  (6,1,2,NULL,'Beloya','2018-07-07 07:32:20',NULL,NULL),
  (7,1,3,NULL,'Beloya','2018-07-07 07:32:20',NULL,NULL),
  (8,1,1,NULL,'Beloya','2018-07-14 10:00:41',NULL,NULL),
  (9,1,1,NULL,'Beloya','2018-07-14 11:04:05',NULL,NULL),
  (10,1,1,NULL,'Beloya','2018-07-14 11:14:52',NULL,NULL),
  (11,1,1,NULL,'Beloya','2018-07-14 11:28:09',NULL,NULL),
  (12,1,1,NULL,'Beloya','2018-07-15 00:40:56',NULL,NULL),
  (13,1,2,NULL,'Beloya','2018-07-15 00:40:56',NULL,NULL),
  (14,1,1,NULL,'Beloya','2018-07-15 08:57:44',NULL,NULL),
  (15,19,1,NULL,'Beloya','2018-07-15 09:05:49',NULL,NULL),
  (16,20,3,NULL,'Beloya','2018-07-16 08:25:42',NULL,NULL),
  (17,21,1,NULL,'Beloya','2018-07-16 10:21:47',NULL,NULL),
  (18,21,2,NULL,'Beloya','2018-07-16 10:21:47',NULL,NULL),
  (19,22,2,NULL,'Beloya','2018-07-17 09:08:05',NULL,NULL),
  (20,22,3,NULL,'Beloya','2018-07-17 09:08:05',NULL,NULL),
  (21,22,1,NULL,'Beloya','2018-07-17 09:08:05',NULL,NULL),
  (22,23,3,NULL,'Beloya','2018-07-19 09:16:27',NULL,NULL),
  (23,23,2,NULL,'Beloya','2018-07-19 09:16:27',NULL,NULL),
  (24,24,1,NULL,'Beloya','2018-07-20 10:55:28',NULL,NULL),
  (25,24,2,NULL,'Beloya','2018-07-20 10:55:28',NULL,NULL),
  (26,25,15,NULL,'Beloya','2018-07-22 03:04:35',NULL,NULL),
  (27,25,1,NULL,'Beloya','2018-07-22 03:04:35',NULL,NULL),
  (28,26,15,NULL,'Beloya','2018-07-24 09:47:09',NULL,NULL),
  (29,26,2,NULL,'Beloya','2018-07-24 09:47:09',NULL,NULL),
  (30,27,1,NULL,'Beloya','2018-07-27 10:39:57',NULL,NULL),
  (31,27,2,NULL,'Beloya','2018-07-27 10:39:57',NULL,NULL),
  (32,28,1,NULL,'Beloya','2018-07-28 20:07:48',NULL,NULL),
  (33,28,2,NULL,'Beloya','2018-07-28 20:07:48',NULL,NULL),
  (34,28,5,NULL,'Beloya','2018-07-28 20:07:48',NULL,NULL),
  (35,29,1,NULL,'Beloya','2018-08-06 21:40:33',NULL,NULL),
  (36,29,2,NULL,'Beloya','2018-08-06 21:40:33',NULL,NULL),
  (37,29,15,NULL,'Beloya','2018-08-06 21:40:33',NULL,NULL),
  (38,31,1,NULL,'Beloya','2018-08-07 16:32:04',NULL,NULL),
  (39,31,2,NULL,'Beloya','2018-08-07 16:32:04',NULL,NULL),
  (40,32,1,NULL,'Beloya','2018-08-12 11:25:20',NULL,NULL),
  (41,32,2,NULL,'Beloya','2018-08-12 11:25:20',NULL,NULL),
  (42,33,1,NULL,'Beloya','2018-08-12 11:48:30',NULL,NULL),
  (43,34,1,NULL,'Beloya','2018-08-14 00:05:44',NULL,NULL),
  (44,35,1,NULL,'com.MyBlog.entity.Users@11541777','2018-08-27 04:10:08',NULL,NULL);
COMMIT;

#
# Data for the `archives` table  (LIMIT -474,500)
#

INSERT INTO `archives` (`AID`, `Title`, `context`, `Type`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`, `Status`, `ReadCount`, `Flag`, `VID`) VALUES

  (1,'搭建自己博客，采用SSM框架(一)配置文件篇','<p>一直想建一个属于自己的博客记录学习过程，但之前苦于学生党没钱买服务器<img src=\"http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/pcmoren_wu_org.png\" alt=\"[污]\"></p><p>由于博客还没建好，就只能在这记录下过程以及踩到的坑。</p><p>反正没人看</p><p><img src=\"https://diygod.me/images/havefun.jpg\" alt=\"\" layer-index=\"1\"></p><p>这次打算用Spring+SpringMvc+Mybaits+Redis+Shrio搭配来制作自己的博客</p><h3><u>首先是Maven的POM依赖包配置</u></h3><div><pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;<br>  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>  &lt;groupId&gt;com.MyBlog1&lt;/groupId&gt;<br>  &lt;artifactId&gt;MyBlog1&lt;/artifactId&gt;<br>  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>  &lt;packaging&gt;war&lt;/packaging&gt;<br>  &lt;dependencies&gt;  <br>  &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>     &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>&lt;!-- 2.Spring dao依赖 --&gt;<br>&lt;!-- spring-jdbc包括了一些如jdbcTemplate的工具类 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;!-- 3.Spring web依赖 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br><br>    &lt;!-- 4.Spring test依赖：方便做单元测试和集成测试 --&gt;<br> &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>     &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br>      &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;<br>        &lt;version&gt;5.0.0.RELEASE&lt;/version&gt;<br>    &lt;/dependency&gt;<br><br>    <br>    &lt;!-- Mybaits --&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;<br>  &lt;version&gt;3.4.2&lt;/version&gt;<br>&lt;/dependency&gt;<br>    &lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;<br>    &lt;version&gt;1.3.2&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- MyBaits分页插件 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;<br>    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;<br>    &lt;version&gt;5.1.4&lt;/version&gt;<br>&lt;/dependency&gt;<br>  &lt;!-- MySQL --&gt;<br>\t&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>    &lt;version&gt;8.0.11&lt;/version&gt;<br>&lt;/dependency&gt;<br>  &lt;!-- commons 连接池 --&gt;<br>\t&lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;1.2.2&lt;/version&gt;<br>\t\t&lt;/dependency&gt;\t\t<br>\t\t\t&lt;dependency&gt;<br>    &lt;groupId&gt;commons-pool&lt;/groupId&gt;<br>    &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;<br>    &lt;version&gt;1.3&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;!--urlrewritefilter --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.tuckey&lt;/groupId&gt;<br>    &lt;artifactId&gt;urlrewritefilter&lt;/artifactId&gt;<br>    &lt;version&gt;4.0.4&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!--junit单元测试 --&gt;<br>\t\t&lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;junit&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;junit&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;4.11&lt;/version&gt;<br>\t\t\t&lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt;<br>\t\t\t&lt;scope&gt;test&lt;/scope&gt;<br>\t\t&lt;/dependency&gt;<br>\t\t&lt;!--junit单元测试 --&gt;<br>\t<br><br><br>&lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;javax&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;7.0&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>\t&lt;dependency&gt;<br>    &lt;groupId&gt;jstl&lt;/groupId&gt;<br>    &lt;artifactId&gt;jstl&lt;/artifactId&gt;<br>    &lt;version&gt;1.2&lt;/version&gt;<br>&lt;/dependency&gt;<br>\t\t&lt;!-- 日志 --&gt;<br>\t\t&lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;log4j&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;log4j&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;1.2.16&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>\t\t&lt;dependency&gt;<br>    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;<br>    &lt;version&gt;1.8.0-beta2&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>\t\t&lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;1.3.1&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>\t\t&lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;commons-io&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;commons-io&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;2.4&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>\t\t&lt;dependency&gt; <br>\t\t\t&lt;groupId&gt;commons-codec&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;commons-codec&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;1.9&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>\t\t    &lt;dependency&gt;<br>\t\t    &lt;!-- json --&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;<br>    &lt;version&gt;2.9.4&lt;/version&gt;<br>    &lt;/dependency&gt;<br>\t &lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br>    &lt;version&gt;2.9.4&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;<br>    &lt;version&gt;2.9.4&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;1.9.4&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>\t\t&lt;dependency&gt;<br>\t\t\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>\t\t\t&lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>\t\t\t&lt;version&gt;1.1.41&lt;/version&gt;<br>\t\t&lt;/dependency&gt;<br>\t\t&lt;!-- Redis缓存 --&gt;<br>\t\t&lt;dependency&gt;<br>    &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>    &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>    &lt;version&gt;2.9.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>\t\t&lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;<br>    &lt;version&gt;1.0.0&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-&gt;    &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!--shrio权限管理框架  --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;<br>    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;<br>    &lt;version&gt;1.4.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;<br>    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;<br>    &lt;version&gt;1.4.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;<br>    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;<br>    &lt;version&gt;1.4.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;<br>    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;<br>    &lt;version&gt;1.4.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;/dependencies&gt;<br>&lt;/project&gt;\n</code></pre><h2>再过来是Web配置</h2></div><div><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt;<br>    <br> &lt;context-param&gt;<br>     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>     &lt;param-value&gt;classpath:Spring-*.xml&lt;/param-value&gt;<br> &lt;/context-param&gt;<br>   &lt;context-param&gt;<br>    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;<br>    &lt;param-value&gt;classpath:/log4j.properties&lt;/param-value&gt;<br>  &lt;/context-param&gt;<br>    &lt;context-param&gt;<br>    &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;<br>    &lt;param-value&gt;60000&lt;/param-value&gt;<br>  &lt;/context-param&gt;<br><br>    &lt;session-config&gt; <br>&lt;!-- Disables URL-based sessions (no more ''jsessionid'' in the URL using Tomcat) --&gt;<br>&lt;tracking-mode&gt;COOKIE&lt;/tracking-mode&gt;<br>&lt;/session-config&gt;<br>    <br>     &lt;!-- 编码过滤器 --&gt;<br>    \t&lt;filter&gt;<br>\t\t&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;<br>\t\t&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;<br>\t\t&lt;async-supported&gt;true&lt;/async-supported&gt;<br>\t\t&lt;init-param&gt;<br>\t\t\t&lt;param-name&gt;encoding&lt;/param-name&gt;<br>\t\t\t&lt;param-value&gt;UTF-8&lt;/param-value&gt;<br>\t\t&lt;/init-param&gt;<br>\t&lt;/filter&gt;<br>\t&lt;filter-mapping&gt;<br>\t\t&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;<br>\t\t&lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br>\t&lt;/filter-mapping&gt;<br>  &lt;!-- shrio过滤器 --&gt;<br>\t  &lt;filter&gt;  <br>      &lt;description&gt;shiro 权限拦截&lt;/description&gt;  <br>      &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;  <br>      &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;  <br>      &lt;init-param&gt;  <br>          &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;  <br>          &lt;param-value&gt;true&lt;/param-value&gt;  <br>      &lt;/init-param&gt;  <br>      &lt;/filter&gt;  <br>      &lt;filter-mapping&gt;  <br>          &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;  <br>          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  <br>             <br>      &lt;/filter-mapping&gt;  <br>      <br>      <br>     \t&lt;!-- Spring MVC servlet --&gt;<br>\t \t&lt;servlet&gt;<br>\t\t&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;<br>\t\t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br>\t\t&lt;init-param&gt;<br>\t\t\t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>\t\t\t&lt;param-value&gt;classpath:SpringMvc.xml&lt;/param-value&gt;<br>\t\t&lt;/init-param&gt;<br>\t\t&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br>\t\t&lt;async-supported&gt;true&lt;/async-supported&gt;<br>\t&lt;/servlet&gt;<br>\t<br>\t&lt;servlet-mapping&gt;<br>\t\t&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;<br>\t\t&lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt;<br>\t\t&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;<br>\t&lt;/servlet-mapping&gt;<br> <br>      <br> &lt;!-- 地址重写过滤器 --&gt;<br> &lt;filter&gt;  <br>        &lt;filter-name&gt;UrlRewriteFilter&lt;/filter-name&gt;  <br>        &lt;filter-class&gt;org.tuckey.web.filters.urlrewrite.UrlRewriteFilter&lt;/filter-class&gt;  <br>        &lt;init-param&gt;  <br>            &lt;param-name&gt;confReloadCheckInterval&lt;/param-name&gt;  <br>            &lt;param-value&gt;500000&lt;/param-value&gt;  <br>        &lt;/init-param&gt;  <br>        &lt;init-param&gt;  <br>                &lt;param-name&gt;logLevel&lt;/param-name&gt;  <br>                &lt;param-value&gt;sysout:ERROR&lt;/param-value&gt;  <br>        &lt;/init-param&gt;  <br>    &lt;/filter&gt;   <br>    &lt;filter-mapping&gt;  <br>        &lt;filter-name&gt;UrlRewriteFilter&lt;/filter-name&gt;  <br>        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  <br>    &lt;/filter-mapping&gt;  <br>    <br><br>\t  <br>\t&lt;!-- Spring监听器 --&gt;<br>\t&lt;listener&gt;<br>\t\t&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;<br>\t&lt;/listener&gt;<br>\t&lt;!-- 防止Spring内存溢出监听器 --&gt;<br>\t&lt;listener&gt;<br>\t\t&lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;<br>\t\t<br>\t&lt;/listener&gt;<br><br>\t&lt;welcome-file-list&gt;<br>\t\t&lt;welcome-file&gt;/index.do&lt;/welcome-file&gt;<br>\t&lt;/welcome-file-list&gt;<br>\t\t &lt;!--jsp-config&gt;  <br>    &lt;jsp-property-group&gt;  <br>        &lt;description&gt;html encoding&lt;/description&gt;  <br>        &lt;display-name&gt;JSPConfiguration&lt;/display-name&gt;  <br>        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;  <br>        &lt;el-ignored&gt;true&lt;/el-ignored&gt;  <br>        &lt;page-encoding&gt;UTF-8&lt;/page-encoding&gt;  <br>        &lt;scripting-invalid&gt;false&lt;/scripting-invalid&gt;  <br>        &lt;include-prelude&gt;&lt;/include-prelude&gt;  <br>        &lt;include-coda&gt;&lt;/include-coda&gt;  <br>    &lt;/jsp-property-group&gt;  <br>&lt;/jsp-config--&gt;  <br>&lt;/web-app&gt;</code></pre><p><i>Shrio过滤器最好放在编码过滤器后面，就是处理好字符集就是Shrio过滤器(建议放在其他过滤器前面，之前就是没注意过配置文件顺序进坑了。捣鼓了半天<img src=\"http://111.231.215.38/FriendChat/plugins/layui/images/face/29.gif\" alt=\"[拜拜]\" layer-index=\"2\">)。</i></p><h2><b>Spring配置</b></h2></div><div><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"<br>\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"<br>\txmlns:context=\"http://www.springframework.org/schema/context\"<br>\txmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:cache=\"http://www.springframework.org/schema/cache\"<br>\txmlns:tx=\"http://www.springframework.org/schema/tx\"<br>\txsi:schemaLocation=\"http://www.springframework.org/schema/beans  <br>\t\thttp://www.springframework.org/schema/beans/spring-beans-4.3.xsd<br>\t\thttp://www.springframework.org/schema/context<br>\thttp://www.springframework.org/schema/context/spring-context-4.3.xsd<br>\thttp://www.springframework.org/schema/tx<br>\t\thttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd <br>\t\t http://www.springframework.org/schema/cache<br>        http://www.springframework.org/schema/cache/spring-cache.xsd\"&gt;<br><br>\t&lt;context:component-scan base-package=\"com.MyBlog.Service\" /&gt;<br>\t &lt;context:component-scan base-package=\"com.MyBlog.ServiceImpl\"/&gt; <br>\t&lt;!-- 数据配置 --&gt;<br>\t&lt;bean id=\"propertyConfigurer\"<br>\t&gt;<br>\t\t&lt;property name=\"locations\"&gt;<br>\t\t\t&lt;list&gt;<br>\t\t\t\t&lt;value&gt;classpath:jdbc.properties&lt;/value&gt;<br>\t\t\t\t&lt;value&gt;classpath:redis.properties&lt;/value&gt;<br>\t\t\t&lt;/list&gt;<br>\t\t&lt;/property&gt;<br>\t&lt;/bean&gt;<br>\t&lt;bean id=\"dataSource\"<br>\t\tdestroy-method=\"close\"&gt;<br>\t\t&lt;property name=\"driverClassName\" value=\"${driver}\" /&gt;<br>\t\t&lt;property name=\"url\" value=\"${url}\" /&gt;<br>\t\t&lt;property name=\"username\" value=\"${username}\" /&gt;<br>\t\t&lt;property name=\"password\" value=\"${password}\" /&gt;<br>\t\t&lt;!-- 初始化连接大小 --&gt;<br>\t\t&lt;property name=\"initialSize\" value=\"${initialSize}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 连接池最大数量 --&gt;<br>\t\t&lt;property name=\"maxActive\" value=\"${maxActive}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 连接池最大空闲 --&gt;<br>\t\t&lt;property name=\"maxIdle\" value=\"${maxIdle}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 连接池最小空闲 --&gt;<br>\t\t&lt;property name=\"minIdle\" value=\"${minIdle}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 获取连接最大等待时间 --&gt;<br>\t\t&lt;property name=\"maxWait\" value=\"${maxWait}\"&gt;&lt;/property&gt;<br>\t&lt;/bean&gt;<br>\t&lt;!-- bean id=\"sqlSessionFactory\"&gt; <br>\t\t&lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"mapperLocations\" <br>\t\tvalue=\"classpath:com/MyBlog/Mapping/*.xml\"&gt;&lt;/property&gt; &lt;/bean --&gt;<br>\t&lt;bean id=\"sqlSessionFactory\"&gt;<br>\t\t&lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;<br><br>\t\t&lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\" /&gt;<br><br>\t&lt;/bean&gt;<br>\t&lt;bean&gt;<br>\t\t&lt;property name=\"basePackage\" value=\"com.MyBlog.Dao\" /&gt;<br>\t\t&lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;<br><br>\t&lt;/bean&gt;<br>\t&lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt;<br>\t\t&lt;!-- 事务传播属性 --&gt;<br>\t\t&lt;tx:attributes&gt;<br>\t\t\t&lt;!-- 所有已get、query、select开头的方法都是只读 --&gt;<br>\t\t\t&lt;tx:method name=\"get*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;tx:method name=\"query*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;tx:method name=\"select*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;!-- 其它的所有方法支持事务设置的属性（异常回滚） --&gt;<br>\t\t\t&lt;tx:method name=\"*\" rollback-for=\"java.lang.Throwing\" /&gt;<br>\t\t&lt;/tx:attributes&gt;<br>\t&lt;/tx:advice&gt;<br><br>\t&lt;bean id=\"txManager\"<br>\t&gt;<br>\t\t&lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;<br>\t&lt;/bean&gt;<br><br>\t&lt;!-- redis数据源 --&gt;<br>\t&lt;bean id=\"poolConfig\"&gt;<br>\t\t&lt;property name=\"maxIdle\" value=\"${redis.maxIdle}\" /&gt;<br>\t\t&lt;property name=\"maxTotal\" value=\"${redis.maxActive}\" /&gt;<br>\t\t&lt;property name=\"maxWaitMillis\" value=\"${redis.maxWait}\" /&gt;<br>\t\t&lt;property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" /&gt;<br>\t&lt;/bean&gt;<br>\t&lt;!-- Spring-redis连接池管理工厂 --&gt;<br>\t&lt;bean id=\"jedisConnectionFactory\"<br>\t<br>\t\tp:host-name=\"${redis.host}\" p:port=\"${redis.port}\" p:password=\"${redis.pass}\"<br>\t\tp:pool-config-ref=\"poolConfig\" /&gt;<br>\t&lt;!-- 配置RedisTemplate，提供了对缓存的增删改查 --&gt;<br>\t&lt;bean id=\"redisTemplate\"&gt;<br>\t\t&lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt;<br>\t&lt;/bean&gt;<br>\t&lt;!-- 使用中间类解决RedisCache.jedisConnectionFactory的静态注入，从而使MyBatis实现第三方缓存 --&gt;<br><br>\t&lt;bean id=\"redisCacheTransfer\"&gt;<br>\t\t&lt;property name=\"jedisConnectionFactory\" ref=\"jedisConnectionFactory\" /&gt;<br>\t&lt;/bean&gt;<br>\t&lt;!-- 配置RedisCacheConfig --&gt;<br>\t&lt;!--bean id=\"SpringcacheManager\"&gt; <br>\t\t&lt;property name=\"caches\"&gt; &lt;set&gt; &lt;bean&gt; <br>\t\t&lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt; &lt;property name=\"name\" <br>\t\tvalue=\"lf_cache\"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean --&gt;<br><br><br>&lt;/beans&gt;</code></pre><h2>jdbc配置文件</h2></div><div><pre><code>driver=com.mysql.cj.jdbc.Driver<br>url=jdbc:mysql://localhost:3306/MyBlog?serverTimezone=UTC  <br>username=root<br>password=admin<br>initialSize=0  <br>maxActive=20  <br>maxIdle=20  <br>minIdle=1  <br>maxWait=60000</code></pre><h2><b>Redis配置</b></h2></div><div><pre><code>redis.host=127.0.0.1<br>redis.port=6379  <br>redis.pass=<br>redis.maxIdle=300  <br>redis.maxActive=600  <br>redis.maxWait=1000  <br>redis.testOnBorrow=true</code></pre><h2><b>SpringMVC配置</b></h2></div><div><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"<br>\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"<br>\txmlns:context=\"http://www.springframework.org/schema/context\"<br>\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"<br>\t\txmlns:aop=\"http://www.springframework.org/schema/aop\"<br>\t\t\t xmlns:task=\"http://www.springframework.org/schema/task\"<br>\txsi:schemaLocation=\"http://www.springframework.org/schema/beans  <br>\thttp://www.springframework.org/schema/beans/spring-beans-4.3.xsd  <br>\thttp://www.springframework.org/schema/context  <br>\thttp://www.springframework.org/schema/context/spring-context-4.3.xsd<br>\t\thttp://www.springframework.org/schema/aop<br>\t http://www.springframework.org/schema/aop/spring-aop-4.3.xsd<br>\thttp://www.springframework.org/schema/mvc  <br>\thttp://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd<br>\t  http://www.springframework.org/schema/task<br>    http://www.springframework.org/schema/task/spring-task-4.3.xsd\"&gt;<br>\t&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;<br>\t<br>\t <br>\t&lt;context:component-scan base-package=\"com.MyBlog.Controller\" /&gt;<br>\t &lt;mvc:annotation-driven /&gt;<br>\t<br>\t&lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;<br>\t &lt;bean id=\"mappingJacksonHttpMessageConverter\"<br> &gt;<br>  &lt;property name=\"supportedMediaTypes\"&gt;<br>   &lt;list&gt;<br>    &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;<br>   &lt;/list&gt;<br>  &lt;/property&gt;<br> &lt;/bean&gt; <br> \t&lt;!-- 配置静态资源，直接映射到对应的文件夹，不被DispatcherServlet处理，3.04新增功能，需要重新设置spring-mvc-3.0.xsd --&gt;<br>\t&lt;mvc:resources mapping=\"/img/**\" location=\"/images/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/fonts/**\" location=\"/user2/images/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/Html\" location=\"/Html\" /&gt;<br>\t&lt;mvc:resources mapping=\"/plugins/**\" location=\"/plugins/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/css/**\" location=\"/css/\" /&gt;<br>\t  &lt;mvc:default-servlet-handler/&gt; <br>\t&lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;<br>&lt;bean&gt;<br>  &lt;property name=\"messageConverters\"&gt;<br>   &lt;list &gt;<br>    &lt;ref bean=\"mappingJacksonHttpMessageConverter\" /&gt;<br>   &lt;/list&gt;<br>  &lt;/property&gt;<br> &lt;/bean&gt;<br> <br>\t&lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;<br>\t&lt;bean&gt;<br>\t\t&lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;<br>\t\t&lt;property name=\"prefix\" value=\"/\" /&gt;<br>\t\t&lt;property name=\"suffix\" value=\".jsp\" /&gt;<br>\t&lt;/bean&gt;<br><br><br>\t&lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;<br>\t&lt;bean id=\"multipartResolver\"  <br>       &gt;  <br>        &lt;!-- 默认编码 --&gt;<br>        &lt;property name=\"defaultEncoding\" value=\"utf-8\" /&gt;  <br>        &lt;!-- 文件大小最大值 --&gt;<br>        &lt;property name=\"maxUploadSize\" value=\"10485760000\" /&gt;  <br>        &lt;!-- 内存中的最大值 --&gt;<br>        &lt;property name=\"maxInMemorySize\" value=\"40960\" /&gt;  <br>    &lt;/bean&gt; <br>&lt;!-- 切面层扫描 --&gt;<br>   &lt;context:component-scan base-package=\"com.share.AOP\"/&gt;<br>&lt;!-- 定时任务扫描 --&gt;<br> &lt;context:component-scan base-package=\"com.share.quartz\" /&gt;<br>    &lt;!--启动@AspectJ支持 默认是false--&gt;<br>    &lt;aop:aspectj-autoproxy proxy-target-/&gt;<br>   &lt;task:annotation-driven /&gt;<br>&lt;/beans&gt;</code></pre><p>在Spring 4.x后 MappingJacksonHttpMessageConverter改为了MappingJackson2HttpMessageConverter，不然会找不到</p><h2><b>Shrio配置文件</b></h2></div><div><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  <br>        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  <br>        \txmlns:cache=\"http://www.springframework.org/schema/cache\"<br>        xsi:schemaLocation=\"http://www.springframework.org/schema/beans <br>        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd<br>        http://www.springframework.org/schema/cache<br>        http://www.springframework.org/schema/cache/spring-cache.xsd\"&gt;      <br>   &lt;bean id=\"shiroEhcacheManager\"&gt;<br>        &lt;property name=\"cacheManagerConfigFile\" value=\"classpath:ehcache-shiro.xml\"/&gt;<br>    &lt;/bean&gt;<br> &lt;bean id=\"shiroFilter\"&gt;<br>&lt;property name=\"securityManager\" ref=\"securityManager\"/&gt;<br> &lt;property name=\"loginUrl\" value=\"/login\" /&gt;<br>        &lt;property name=\"successUrl\" value=\"/suc.htm\" /&gt;<br>        &lt;property name=\"unauthorizedUrl\" value=\"/jsp/erro.htm\" /&gt;<br>        &lt;property name=\"filterChainDefinitions\"&gt;<br>            &lt;value&gt;<br><br>             /login.htm = anon<br>         /login = anon<br>              /index.htm = anon<br>              /index = anon<br>            /erro.htm = anon<br>            /Nav.htm = anon<br>            /plugins/** = anon<br>    /images/** = anon<br>    /css/** = anon<br>    /js/** = anon<br>            /SignOut.html = anon<br>            /QuickLogin.html=anon<br>            /LogOut.html=anon<br>             /login.do = anon<br>             <br>               /Newarchives.html=perms[普通:文章:create]  <br>               /Createarchives.html=perms[普通:文章:create] <br>            /admin/** = authc<br>            &lt;/value&gt;<br>              &lt;/property&gt;<br>&lt;/bean&gt;<br><br>     &lt;!-- 会话Cookie --&gt; <br>       &lt;bean id=\"sessionIdCookie\"&gt;  <br>    &lt;constructor-arg value=\"sid\"/&gt;  <br>    &lt;property name=\"httpOnly\" value=\"true\"/&gt;  <br>    <br>    &lt;property name=\"maxAge\" value=\"-1\"/&gt; <br>&lt;/bean&gt;  <br>&lt;bean id=\"sessionManager\"&gt; <br>        &lt;!-- 会话超时时间，单位：毫秒  20m=1200000ms, 30m=1800000ms, 60m=3600000ms--&gt;<br>        &lt;property name=\"globalSessionTimeout\" value=\"7200000\"/&gt;<br>        &lt;property name=\"sessionValidationInterval\" value=\"1200000\"/&gt;<br>        &lt;!-- 去掉 JSESSIONID --&gt;<br>        &lt;property name=\"sessionIdUrlRewritingEnabled\" value=\"false\" /&gt;<br>        &lt;property name=\"sessionValidationSchedulerEnabled\" value=\"true\"/&gt;<br>        &lt;property name=\"sessionIdCookie\" ref=\"sessionIdCookie\"/&gt;<br>        &lt;property name=\"sessionIdCookieEnabled\" value=\"true\"/&gt;<br>&lt;/bean&gt;<br>  &lt;bean id=\"rememberMeCookie\"&gt;<br>         &lt;constructor-arg value=\"COOKIE_NAME\" /&gt;<br>        &lt;property name=\"httpOnly\" value=\"true\" /&gt;<br>        &lt;property name=\"maxAge\" value=\"604800\" /&gt;<br>    &lt;/bean&gt;<br>    &lt;bean id=\"rememberMeManager\"&gt;<br>         &lt;property name=\"cipherKey\" value=\"#{T(org.apache.shiro.codec.Base64).decode(''4AvVhmFLUs0KTA3Kprsdag=='')}\" /&gt;<br>         &lt;property name=\"cookie\" ref=\"rememberMeCookie\" /&gt;<br>     &lt;/bean&gt;<br>      &lt;bean&gt;<br>         &lt;property name=\"securityManager\" ref=\"securityManager\" /&gt;<br>     &lt;/bean&gt;<br>      <br>      &lt;!-- 配置进行授权和认证的 Realm --&gt;  <br>        &lt;bean id=\"myRealm\"&gt;  <br>             &lt;property name=\"userService\" ref=\"userService\" /&gt;  <br>         &lt;/bean&gt;  <br>         &lt;bean id=\"userService\" /&gt;  <br>   <br>   &lt;bean id=\"securityManager\"&gt;  <br>            &lt;property name=\"cacheManager\" ref=\"shiroEhcacheManager\"/&gt;   <br>             &lt;property name=\"realm\" ref=\"myRealm\"/&gt;   <br>             &lt;property name=\"sessionMode\" value=\"native\"&gt;  <br>            <br>             &lt;/property&gt;  <br>              &lt;property name=\"rememberMeManager\" ref=\"rememberMeManager\"/&gt; <br>       &lt;/bean&gt;  <br>      &lt;bean id=\"lifecycleBeanPostProcessor\"/&gt;  <br>  <br> <br><br>        &lt;/beans&gt;</code></pre><h2><b>Mybaits配置文件</b></h2></div><div><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" <br>\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;<br>&lt;configuration&gt;<br><br>\t &lt;!-- 配置mybatis的缓存，延迟加载等相关属性 --&gt;<br> &lt;settings&gt;<br><br>        &lt;!-- 全局映射器启用缓存 --&gt;<br>        &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;<br><br>        &lt;!-- 查询时，关闭关联对象即时加载以提高性能 --&gt;<br>        &lt;setting name=\"lazyLoadingEnabled\" value=\"false\"/&gt;<br><br>        &lt;!-- 对于未知的SQL查询，允许返回不同的结果集以达到通用的效果 --&gt;<br>        &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt;<br><br>        &lt;!-- 允许使用列标签代替列名 --&gt;<br>        &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt;<br><br>        &lt;!-- 不允许使用自定义的主键值(比如由程序生成的UUID 32位编码作为键值)，数据表的PK生成策略将被覆盖 --&gt;<br>        &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt;<br><br>        &lt;!-- 给予被嵌套的resultMap以字段-属性的映射支持 FULL,PARTIAL --&gt;<br>        &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt;<br><br>        &lt;!-- 对于批量更新操作缓存SQL以提高性能 BATCH,SIMPLE --&gt;<br>        &lt;!-- &lt;setting name=\"defaultExecutorType\" value=\"BATCH\" /&gt; --&gt;<br><br>        &lt;!-- 数据库超过25000秒仍未响应则超时 --&gt;<br>        &lt;!-- &lt;setting name=\"defaultStatementTimeout\" value=\"25000\" /&gt; --&gt;<br><br>        &lt;!-- Allows using RowBounds on nested statements --&gt;<br>        &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt;<br><br>        &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn. --&gt;<br>        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;<br><br>        &lt;!-- MyBatis uses local cache to prevent circular references and speed up repeated nested queries. By default (SESSION) all queries executed during a session are cached. If localCacheScope=STATEMENT <br>            local session will be used just for statement execution, no data will be shared between two different calls to the same SqlSession. --&gt;<br>        &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;<br><br>        &lt;!-- Specifies the JDBC type for null values when no specific JDBC type was provided for the parameter. Some drivers require specifying the column JDBC type but others work with generic values <br>            like NULL, VARCHAR or OTHER. --&gt;<br>        &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt;<br><br>        &lt;!-- Specifies which Object''s methods trigger a lazy load --&gt;<br>        &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;<br><br>        &lt;!-- 设置关联对象加载的形态，此处为按需加载字段(加载字段由SQL指 定)，不会加载关联表的所有字段，以提高性能 --&gt;<br>        &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt;<br><br>    &lt;/settings&gt;<br>    \t&lt;typeAliases&gt;<br>\t<br><br>\t\t&lt;!-- 当所有的model类都在统一一个package下，且别名与类名相同，可以配置一个package减少配置，代码可读性更好 --&gt;<br>\t\t&lt;package name=\"com.MyBlog.entity\" /&gt;<br><br>\t&lt;/typeAliases&gt;<br>\t&lt;plugins&gt;<br>    &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt;<br>    &lt;property name=\"rowBoundsWithCount\" value=\"true\"/&gt;<br><br>     &lt;property name=\"reasonable\" value=\"true\"/&gt;<br>        &lt;property name=\"offsetAsPageNum\" value=\"true\"/&gt;<br>           &lt;property name=\"pageSizeZero\" value=\"true\"/&gt;<br>        <br>\t&lt;/plugin&gt;<br>&lt;/plugins&gt;<br>&lt;/configuration&gt;</code></pre><p>在配置文件中的位置必须符合要求，否则会报错，顺序如下:&nbsp;<br>properties,&nbsp;<br>settings,&nbsp;<br>typeAliases,&nbsp;<br>typeHandlers,&nbsp;<br>objectFactory,&nbsp;<br>objectWrapperFactory,&nbsp;<br>plugins,&nbsp;<br>environments,&nbsp;<br>databaseIdProvider,&nbsp;</p><p>mappers</p><h2><b>Shrio缓存配置</b></h2></div><div><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>&lt;ehcache updateCheck=\"false\"  name=\"shiroCache\"&gt;<br><br>    &lt;diskStore path=\"java.io.tmpdir\"/&gt;<br>    &lt;defaultCache<br>            maxElementsInMemory=\"10000\"<br>            eternal=\"false\"<br>            timeToIdleSeconds=\"120\"<br>            timeToLiveSeconds=\"120\"<br>            overflowToDisk=\"false\"<br>            diskPersistent=\"false\"<br>            diskExpiryThreadIntervalSeconds=\"120\"<br>    /&gt;<br><br>    &lt;cache name=\"passwordRetryCache\"<br>        <br>           eternal=\"false\"<br>           timeToIdleSeconds=\"3600\"<br>           timeToLiveSeconds=\"0\"<br>           overflowToDisk=\"false\"<br>           statistics=\"true\"&gt;<br>    &lt;/cache&gt;<br>    &lt;cache name=\"authorizationCache\"<br>   <br>           eternal=\"false\"<br>           timeToIdleSeconds=\"3600\"<br>           timeToLiveSeconds=\"0\"<br>           overflowToDisk=\"false\"<br>           statistics=\"true\"&gt;<br>    &lt;/cache&gt;<br>    &lt;cache name=\"authenticationCache\"<br><br>           eternal=\"false\"<br>           timeToIdleSeconds=\"3600\"<br>           timeToLiveSeconds=\"0\"<br>           overflowToDisk=\"false\"<br>           statistics=\"true\"&gt;<br>    &lt;/cache&gt;<br>    &lt;cache name=\"shiro-activeSessionCache\"<br>        <br>           eternal=\"false\"<br>           timeToIdleSeconds=\"3600\"<br>           timeToLiveSeconds=\"0\"<br>           overflowToDisk=\"false\"<br>           statistics=\"true\"&gt;<br>    &lt;/cache&gt;<br>    &lt;cache name=\"shiro_cache\"<br>           maxElementsInMemory=\"2000\"<br><br>           eternal=\"false\"<br>           timeToIdleSeconds=\"0\"<br>           timeToLiveSeconds=\"0\"<br>           maxElementsOnDisk=\"0\"<br>           overflowToDisk=\"true\"<br>           memoryStoreEvictionPolicy=\"FIFO\"<br>           statistics=\"true\"&gt;<br>    &lt;/cache&gt;<br>&lt;/ehcache&gt;</code></pre><p>注意该Shrio缓存配置文件里不要加任何中文注释。不然会报错</p><p>写到这里，我的博客也差不多建好了。这是我博客第一条博文</p><p><img src=\"http://localhost:8090/MyBlog1/userTempImg/180706_232130_header-darling2.jpg\"></p></div>',1,'Beloya','2018-07-07 01:38:18',NULL,NULL,0,229,0,1),
  (9,'Mybatis插入返回主键','<p>这个还需求很常见，所以列出来。</p><h2><span style=\"font-weight: bold;\">一、实现方式</span></h2><h5 id=\"1-使用usegeneratedkeyskeyproperty-推荐\">1. 使用useGeneratedKeys+keyProperty (推荐)</h5><p>简单来说就是配置：</p><pre><code>&lt;insert id=\"\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt;</code></pre><p>将插入的ID赋值给设置的keyProperty对象属性字段里面，一般也就是对象的ID，比如插入User对象，设置赋值主键ID给id字段。</p><h5 id=\"2-使用selectkey\">2. 使用selectKey</h5><p>MySQL 数据库可以使用如下方式。</p><pre><code>&lt;selectKey resultType=\"int\" order=\"AFTER\" keyProperty=\"aid\"&gt;  <br>                SELECT LAST_INSERT_ID() <br>     &lt;/selectKey&gt;</code></pre><p><br></p>',1,'Beloya','2018-07-07 07:29:29',NULL,NULL,0,111,0,1),
  (10,'NoSuchBeanDefinitionException: No qualifying bean of type报错问题','<p>昨天还运行好好地，今天新增模块时莫名其妙就跑不起来了，找了一大堆资料，排查N年后发现，是我的l配置文件中没有扫描到我的serviceImpl实现类导致无法注入，解决方法：1.添加serviceImpl扫描的路径，2.把现实类和服务接口放在一个包下统一扫描。</p><p>明明昨天都还跑着，今天就要加扫描路径。没弄明白<img src=\"http://111.231.215.38/FriendChat/plugins/layui/images/face/61.gif\" alt=\"[囧]\" layer-index=\"0\"></p><p><b>还有一种情况也会导致这种问题，也就记录下来</b></p><p>造成这一异常的原因可能是Spring上下文中存在两个或以上该bean的定义。如果接口IService 有两个实现类 ServiceImplA 和ServiceImplB&nbsp;<br>接口：IService.java</p><pre name=\"code\"><code>package com.csdn.training.service;\n\npublic interface IService {\n\n}</code></pre><p>两个实现类：ServiceImplA.java</p><pre name=\"code\"><code>package com.csdn.training.service;\n\nimport org.springframework.stereotype.Service;\n@Service\npublic class ServiceImplA implements IService {\n\n}</code></pre><p>ServiceImplB.java</p><pre name=\"code\"><code>package com.csdn.training.service;\n\nimport org.springframework.stereotype.Service;\n@Service\npublic class ServiceImplB implements IService {\n\n}</code></pre><p>如果BeanA 自动注入这一接口，Spring就无法分辨到底注入哪一个实现类：</p><pre name=\"code\"><code>package com.csdn.training.model;\n\nimport com.csdn.training.service.IService;\n@Component\npublic class BeanA {    \n    @Autowired\n    private IService serviceImpl;\n}</code></pre><p>然后，BeanFactory就抛出异常NoSuchBeanDefinitionException&nbsp;<br>Spring会提示：”<em>expected single matching bean but found 2</em>“（只应该匹配一个bean但是找到了多个）</p><pre name=\"code\"><code>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: \nNo qualifying bean of type [com.csdn.training.service.IService] is defined: \nexpected single matching bean but found 2: serviceImplA,serviceImplB</code></pre><p>上例中，有时你看到的异常信息是NoUniqueBeanDefinitionException，它是NoSuchBeanDefinitionException 它的子类，在Spring 3.2.1中，修正了这一异常，为的是和bean未定义这一异常区分开。</p><pre name=\"code\"><code>nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [com.csdn.training.service.IService] is defined: expected single matching bean but found 2: serviceImplA,serviceImplB</code></pre><p>解决这一异常可以用注解@Qualifier 来指定想要注入的bean的名字。</p><pre name=\"code\"><code>package com.csdn.training.model;\n\nimport com.csdn.training.service.IService;\n@Component\npublic class BeanA {\n    @Autowired\n    @Qualifier(\"serviceImplA\")\n    private IService serviceImpl;\n}</code></pre><p>修改以后，Spring就可以区分出应该注入那个bean的实例，需要注意的是ServiceImplA的默认实例名称是serviceImplA</p><p><br></p>',1,'Beloya','2018-07-07 07:32:20','Beloya','2018-07-13 11:34:02',0,184,0,1),
  (12,'Shiro 编码加密','<p>博客准备弄个注册账号功能，原本准备随便弄弄的，但是想想前不久发生在AcFun的脱裤闹得沸沸扬扬的，没有任何系统不存在漏洞，不可能不犯错，那就只有把翻车的概率降低</p><p>在做数据的存储方案时，我们需要假设储存的数据已经被泄露出去了，如用户密码这种隐私数据的存储就是一个重点。</p><blockquote>讲密码的存储方案前，先要记住三条前提：<br>用户喜欢到处使用一样的密码<br>用户喜欢使用简单好记的密码<br>世界上没有绝对的安全，但当攻击成本远高于收益时，整个系统达到相对安全</blockquote><p>这次打算用Shrio框架自带的密码加密功能</p><p>在使用前先熟悉一下</p><h2>编码 / 解码</h2><div>Shiro 提供了 base64 和 16 进制字符串编码 / 解码的 API 支持，方便一些编码解码操作。Shiro 内部的一些数据的存储 / 表示都使用了 base64 和 16 进制字符串。</div><pre><code>String str = \"userName\";<br>\t\t String base64Encoded = Base64.encodeToString(str.getBytes());<br>\t\t String str2 = Base64.decodeToString(base64Encoded);<br>\t\t System.out.println(\"编码结果:\"+base64Encoded);<br>\t\t System.out.println(\"解码结果:\"+str2);</code></pre><p>输出结果：</p><blockquote>编码结果:dXNlck5hbWU=<br>解码结果:userName</blockquote><p>还可以进行 16 进制字符串编码 / 解码操作</p><pre><code>String str = \"hello\";<br>\t\t String base64Encoded = Hex.encodeToString(str.getBytes());<br>\t\t String str2 = new String(Hex.decode(base64Encoded.getBytes()));<br>\t\tSystem.out.println(\"编码结果：\"+base64Encoded);<br>\t\tSystem.out.println(\"解码结果：\"+str2);</code></pre><p>输出结果：</p><blockquote>编码结果：68656c6c6f<br>解码结果：hello</blockquote><h2>散列算法</h2><div>散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如 MD5、SHA 等。一般进行散列时最好提供一个 salt（盐），比如加密密码 “admin”，产生的散列值是 “21232f297a57a5a743894a0e4a801fc3”</div><pre><code>String str = \"hello\";<br>\t\t String md5 = new Md5Hash(str).toString();<br>\t\tSystem.out.println(\"结果：\"+md5);</code></pre><p>输出结果：</p><blockquote>结果：5d41402abc4b2a76b9719d911017c592</blockquote><p>散列时还可以指定散列次数，如 2 次表示：md5(md5(str))：“new Md5Hash(str, salt, 2).toString()”。</p><p>使用 SHA256 算法生成相应的散列数据，另外还有如 SHA1、SHA512 算法。</p><p>Shiro 还提供了通用的散列支持：</p><pre><code>String str = \"hello\";<br>String salt = \"123\";<br>//内部使用MessageDigest<br>String simpleHash = new SimpleHash(\"SHA-1\", str, salt).toString();&nbsp;</code></pre><blockquote>通过调用 SimpleHash 时指定散列算法，其内部使用了 Java 的 MessageDigest 实现。</blockquote><p>为了方便使用，Shiro 提供了 HashService，默认提供了 DefaultHashService 实现。</p><blockquote>DefaultHashService hashService = new&nbsp;DefaultHashService();&nbsp;//默认算法SHA-512&nbsp;hashService.setHashAlgorithmName(\"SHA-512\"); hashService.setPrivateSalt(new&nbsp;SimpleByteSource(\"123\"));&nbsp;//私盐，默认无&nbsp;hashService.setGeneratePublicSalt(true);//是否生成公盐，默认false&nbsp;hashService.setRandomNumberGenerator(new&nbsp;SecureRandomNumberGenerator());//用于生成公盐。默认就这个&nbsp;hashService.setHashIterations(1);&nbsp;//生成Hash值的迭代次数&nbsp;HashRequest request =&nbsp;new&nbsp;HashRequest.Builder() .setAlgorithmName(\"MD5\").setSource(ByteSource.Util.bytes(\"hello\")) .setSalt(ByteSource.Util.bytes(\"123\")).setIterations(2).build();&nbsp;String&nbsp;hex = hashService.computeHash(request).toHex();</blockquote><ol><li>首先创建一个 DefaultHashService，默认使用 SHA-512 算法；</li><li>以通过 hashAlgorithmName 属性修改算法；</li><li>可以通过 privateSalt 设置一个私盐，其在散列时自动与用户传入的公盐混合产生一个新盐；</li><li>可以通过 generatePublicSalt 属性在用户没有传入公盐的情况下是否生成公盐；</li><li>可以设置 randomNumberGenerator 用于生成公盐；</li><li>可以设置 hashIterations 属性来修改默认加密迭代次数；</li><li>需要构建一个 HashRequest，传入算法、数据、公盐、迭代次数。</li></ol><h2>SecureRandomNumberGenerator 用于生成一个随机数：</h2><pre><code>SecureRandomNumberGenerator randomNumberGenerator =<br>     new SecureRandomNumberGenerator();<br>randomNumberGenerator.setSeed(\"123\".getBytes());<br>String hex = randomNumberGenerator.nextBytes().toHex();</code></pre><h2>Shiro 还提供对称式加密 / 解密算法的支持，如 AES、Blowfish 等；</h2><p>AES 算法实现：</p><pre><code>AesCipherService aesCipherService = new AesCipherService();<br>aesCipherService.setKeySize(128); //设置key长度<br>//生成key<br>Key key = aesCipherService.generateNewKey();<br>String text = \"hello\";<br>//加密<br>String encrptText = <br>aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();<br>//解密<br>String text2 =<br> new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());<br>Assert.assertEquals(text, text2);</code></pre><h2>PasswordService/CredentialsMatcher</h2><pre><code>public interface PasswordService {<br>    //输入明文密码得到密文密码<br>    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;<br>}</code></pre><pre><code>public interface CredentialsMatcher {<br>    //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）<br>    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);<br>}</code></pre><p>Shiro 默认提供了 PasswordService 实现 DefaultPasswordService；CredentialsMatcher 实现 PasswordMatcher 及 HashedCredentialsMatcher（更强大）。</p><h3><strong>DefaultPasswordService 配合 PasswordMatcher 实现简单的密码加密与验证服务</strong></h3><div>1、定义 Realm</div><pre><code>public class MyRealm extends AuthorizingRealm {<br>    private PasswordService passwordService;<br>    public void setPasswordService(PasswordService passwordService) {<br>        this.passwordService = passwordService;<br>    }<br>     //省略doGetAuthorizationInfo，具体看代码 <br>    @Override<br>    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {<br>        return new SimpleAuthenticationInfo(<br>                \"wu\",                passwordService.encryptPassword(\"123\"),<br>                getName());<br>    }<br>}</code></pre><p>为了方便，直接注入一个 passwordService 来加密密码，实际使用时需要在 Service 层使用 passwordService 加密密码并存到数据库。</p><p>2、ini 配置（shiro-passwordservice.ini）</p><pre><code>[main]\npasswordService=org.apache.shiro.authc.credential.DefaultPasswordService\nhashService=org.apache.shiro.crypto.hash.DefaultHashService\npasswordService.hashService=$hashService\nhashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormat\npasswordService.hashFormat=$hashFormat\nhashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory\npasswordService.hashFormatFactory=$hashFormatFactory\npasswordMatcher=org.apache.shiro.authc.credential.PasswordMatcher\npasswordMatcher.passwordService=$passwordService\nmyRealm=com.github.zhangkaitao.shiro.chapter5.hash.realm.MyRealm\nmyRealm.passwordService=$passwordService\nmyRealm.credentialsMatcher=$passwordMatcher\nsecurityManager.realms=$myRealm\n</code></pre><ol><li>passwordService 使用 DefaultPasswordService，如果有必要也可以自定义；</li><li>hashService 定义散列密码使用的 HashService，默认使用 DefaultHashService（默认 SHA-256 算法）；</li><li>hashFormat 用于对散列出的值进行格式化，默认使用 Shiro1CryptFormat，另外提供了 Base64Format 和 HexFormat，对于有 salt 的密码请自定义实现 ParsableHashFormat 然后把 salt 格式化到散列值中；</li><li>hashFormatFactory 用于根据散列值得到散列的密码和 salt；因为如果使用如 SHA 算法，那么会生成一个 salt，此 salt 需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用 DefaultHashFormatFactory；</li><li>passwordMatcher 使用 PasswordMatcher，其是一个 CredentialsMatcher 实现；</li><li>将 credentialsMatcher 赋值给 myRealm，myRealm 间接继承了 AuthenticatingRealm，其在调用 getAuthenticationInfo 方法获取到 AuthenticationInfo 信息后，会使用 credentialsMatcher 来验证凭据是否匹配，如果不匹配将抛出 IncorrectCredentialsException 异常。</li></ol><p><strong>HashedCredentialsMatcher 实现密码验证服务</strong></p><p>Shiro 提供了 CredentialsMatcher 的散列实现 HashedCredentialsMatcher，和之前的 PasswordMatcher 不同的是，它只用于密码验证，且可以提供自己的盐，而不是随机生成盐，且生成密码散列值的算法需要自己写，因为能提供自己的盐。</p><p>1、生成密码散列值</p><p>此处我们使用 MD5 算法，“密码 + 盐（用户名 + 随机数）” 的方式生成散列值：</p><pre><code>String algorithmName = \"md5\";\nString username = \"liu\";\nString password = \"123\";\nString salt1 = username;\nString salt2 = new SecureRandomNumberGenerator().nextBytes().toHex();\nint hashIterations = 2;\nSimpleHash hash = new SimpleHash(algorithmName, password, salt1 + salt2, hashIterations);\nString encodedPassword = hash.toHex();</code></pre><p>如果要写用户模块，需要在新增用户 / 重置密码时使用如上算法保存密码，将生成的密码及 salt2 存入数据库（因为我们的散列算法是：md5(md5(密码 +username+salt2))）。</p><p>2、生成 Realm（com.github.zhangkaitao.shiro.chapter5.hash.realm.MyRealm2）</p><pre><code>protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    String username = \"liu\"; //用户名及salt1\n    String password = \"202cb962ac59075b964b07152d234b70\"; //加密后的密码\n    String salt2 = \"202cb962ac59075b964b07152d234b70\";\nSimpleAuthenticationInfo ai = \n        new SimpleAuthenticationInfo(username, password, getName());\n    ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt2)); //盐是用户名+随机数\n        return ai;\n}&amp;nbsp;</code></pre><p>此处就是把步骤 1 中生成的相应数据组装为 SimpleAuthenticationInfo，通过 SimpleAuthenticationInfo 的 credentialsSalt 设置盐，HashedCredentialsMatcher 会自动识别这个盐。</p><p>如果使用 JdbcRealm，需要修改获取用户信息（包括盐）的&nbsp;<code>sql：“select password, password_salt from users where username = ?”</code>，而我们的盐是由 username+password_salt 组成，所以需要通过如下 ini 配置（shiro-jdbc-hashedCredentialsMatcher.ini）修改：</p><pre><code>jdbcRealm.saltStyle=COLUMN\njdbcRealm.authenticationQuery=select password, concat(username,password_salt) from users where username = ?\njdbcRealm.credentialsMatcher=$credentialsMatcher</code></pre><ul><li>saltStyle 表示使用密码 + 盐的机制，authenticationQuery 第一列是密码，第二列是盐；</li><li>通过 authenticationQuery 指定密码及盐查询 SQL；</li></ul><p>此处还要注意 Shiro 默认使用了 apache commons BeanUtils，默认是不进行 Enum 类型转型的，此时需要自己注册一个 Enum 转换器 “BeanUtilsBean.getInstance().getConvertUtils().register(new EnumConverter(), JdbcRealm.SaltStyle.class);” 具体请参考示例 “com.github.zhangkaitao.shiro.chapter5.hash.PasswordTest” 中的代码。</p><p>另外可以参考配置 shiro-jdbc-passwordservice.ini，提供了 JdbcRealm 的测试用例，测试前请先调用 sql/shiro-init-data.sql 初始化用户数据。</p><p>3、ini 配置（shiro-hashedCredentialsMatcher.ini）</p><pre><code>[main]\ncredentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher\ncredentialsMatcher.hashAlgorithmName=md5\ncredentialsMatcher.hashIterations=2\ncredentialsMatcher.storedCredentialsHexEncoded=true\nmyRealm=com.github.zhangkaitao.shiro.chapter5.hash.realm.MyRealm2\nmyRealm.credentialsMatcher=$credentialsMatcher\nsecurityManager.realms=$myRealm</code></pre><ul><li>通过 credentialsMatcher.hashAlgorithmName=md5 指定散列算法为 md5，需要和生成密码时的一样；</li><li>credentialsMatcher.hashIterations=2，散列迭代次数，需要和生成密码时的意义；</li><li>credentialsMatcher.storedCredentialsHexEncoded=true 表示是否存储散列后的密码为 16 进制，需要和生成密码时的一样，默认是 base64；</li></ul><p>此处最需要注意的就是 HashedCredentialsMatcher 的算法需要和生成密码时的算法一样。另外 HashedCredentialsMatcher 会自动根据 AuthenticationInfo 的类型是否是 SaltedAuthenticationInfo 来获取 credentialsSalt 盐。</p><h2><strong>密码重试次数限制</strong></h2><div>如在 1 个小时内密码最多重试 5 次，如果尝试次数超过 5 次就锁定 1 小时，1 小时后可再次重试，如果还是重试失败，可以锁定如 1 天，以此类推，防止密码被暴力破解。我们通过继承 HashedCredentialsMatcher，且使用 Ehcache 记录重试次数和超时时间。</div><pre><code>public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {<br>       String username = (String)token.getPrincipal();<br>        //retry count + 1<br>        Element element = passwordRetryCache.get(username);<br>        if(element == null) {<br>            element = new Element(username , new AtomicInteger(0));<br>            passwordRetryCache.put(element);<br>        }<br>        AtomicInteger retryCount = (AtomicInteger)element.getObjectValue();<br>        if(retryCount.incrementAndGet() &gt; 5) {<br>            //if retry count &gt; 5 throw<br>            throw new ExcessiveAttemptsException();<br>        }<br>        boolean matches = super.doCredentialsMatch(token, info);<br>        if(matches) {<br>            //clear retry count<br>            passwordRetryCache.remove(username);<br>        }<br>        return matches;<br>}</code></pre><p><br></p>',1,'Beloya','2018-07-10 15:31:59','Beloya','2018-07-13 11:28:44',0,107,0,1),
  (13,'菜鸟学习设计模式系列-概述','<h1 style=\"text-align: center;\"><span style=\"font-weight: bold;\">前言</span></h1><h1 style=\"text-align: center;\"><p>博客总算弄好了基本功能，本来是打算记录些平常遇到的问题和坑，但发现总是刚入这个坑，这个坑还没填完又入别的坑，学的东西太碎了也不够深入，所以打算专门开个系列，来个专门性的学习。</p></h1><h1 style=\"text-align: center;\"><span style=\"font-weight: bold;\">写什么</span></h1><h1 style=\"text-align: center;\"><div>这次打算围绕着设计模式来写，设计模式可以说是在开发中担任非常重要的角色，设计模式是针对某一类问题的最优解决方案，是从许多优秀的软件系统中总结出的，无论是java基础类库的设计还是Spring体系的设计基本都离不开设计模式的使用。设计模式中基本上都是围绕六种设计原则来约束的，，再利用JAVA中提供抽象、继承、多态提供的机制来进行具体的实现。顺着这个思路简单罗列下我自己的学习路线：</div><div><div>因为需要使用JAVA，那么就必须先要对抽象、封装、继承和多态有一个比较清楚的理解，因此第一部分将会从java语言本身的特色来学习，主要包括：</div><div><blockquote><p></p><ul><li><span style=\"font-family: 宋体;\">1.抽象，封装，继承，多态的理解</span></li></ul><ul><li><span style=\"font-family: 宋体;\">2.类和接口</span></li></ul><ul><li><span style=\"font-family: 宋体;\">3.面向接口编程的理解</span></li></ul><ul><li><span style=\"font-family: 宋体;\">第二部分就直接进入设计模式范畴之内：</span></li></ul><ul><li><span style=\"font-family: 宋体;\">1.设计原则</span></li></ul><ul><li><span style=\"font-family: 宋体;\">2.创建型</span></li></ul><ul><li><span style=\"font-family: 宋体;\">3.结构型</span></li></ul><ul><li><span style=\"font-family: 宋体;\">4.行为型</span></li></ul><p></p></blockquote><div><br></div></div><br></div><br></h1><p><br></p>',2,'Beloya','2018-07-14 10:00:41','Beloya','2018-07-14 04:32:19',0,35,0,1),
  (16,'菜鸟学习设计模式系列-面向对象','<h1>抽象</h1><p>抽象就是对事物的共性进行概括抽象出来。关于抽象，就是从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。在JAVA中表现就是使用abstract来修饰类，被abstract修饰的类成为抽象类，一般是为了为子类提供一些共有的属性和行为，不同的子类根据自身的特性再进行具体的行为实现。</p><h1>封装</h1><p>封装是面向对象的重要原则，就是把对象的属性和行为封装成一个整体，不像外界展示它的内部，就好比手机你不需要知道它内部是怎么实现的，只需要知道它能提供什么功能；在java中，对于对象的内部属性一般用private来实现隐藏，并通过set和get方法对外提供访问接口。</p><ul>\n<li>对象的数据封装特性彻底消除了传统结构方法中数据与操作分离所带来的种种问题，提高了程序的可复用性和可维护性，降低了程序员保持数据与操作内容的负担。</li>\n<li>对象的数据封装特性还可以把对象的私有数据和公共数据分离开，保护了私有数据，减少了可能的模块间干扰，达到降低程序复杂性、提高可控性的目的。</li>\n</ul><p>例如：对于笔来说；使用private关键字来修饰笔的属性，并通过对应的set和get方法对外界提供访问入口；在行为方面，通过public关键字来修饰，对外提供具体的行为描述。外界对象并不知道“笔”这个对象在内部发生了什么，仅仅是通过提供的方法来获得具体的描述信息。</p><blockquote>访问控制修饰符&nbsp;<br>①public：公开级别，对外公开&nbsp;<br>②protected：受保护级别，对子类和同一个包中的类公开&nbsp;<br>③无修饰符：默认级别，向同一个包的类公开&nbsp;<br>④private：私有级别，只有类本身可以访问，不对外公开</blockquote><pre><code lang=\"bash\"><p>/**<br> * 笔<br> * @author Beloya<br> *<br> */</p><p>public class Pen {<br>\t//颜色<br>\tprivate String color;<br>\t//长度<br>\tprivate int length;<br>\t<br>\t  public String getColor() {<br>        return color;<br>    }<br>    public void setColor(String color) {<br>        this.color = color;<br>    }<br>    public int getLength() {<br>        return length;<br>    }<br>\tpublic void setLength(){<br>\t\t this.length = length;<br>\t}<br>}</p></code></pre><h1>继承</h1><p>继承可以解决代码复用，让变成更接近人的思维，当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，子类继承父类的属性和行为，并能根据自己的需求扩展出新的属性和行为，提高了代码的可复用性。 </p><ul>\n<li>提高了代码的复用性。</li>\n<li>让类与类之间产生了关系，给第三个特征多态提供了前提。</li>\n</ul><p>Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类称为父类(有的也称其为基类、超类)，父类和子类的关系，是一种一般和特殊的关系；子类扩展父类，将可以获得父类的全部属性和方法。</p><p>圆珠笔是笔的一种，圆珠笔除了父类笔的写的行为可以写以外还可以转笔这个特征。圆珠笔继承了笔这个父类，那么圆珠笔也有长度和颜色等属性</p><pre><code lang=\"bash\"><p>/**<br> * 圆珠笔<br> * @author Beloya<br> *<br> */</p><p> public class ballpoint extends Pen{<br>\t <br>\t public void pen_spinning(){<br>\t\t      System.out.println(\"我要转笔\");<br>\t }<br> }</p></code></pre><p>重写父类的方法：<br>大部分的时候，子类总是以父类为基础，额外添加新的属性和方法。但有一种情况例外：子类需要重写父类的方法。例如圆珠笔写字比毛笔快。</p><pre><code lang=\"bash\"><p>@Override<br>public void writer(){<br>    System.out.println(\"快速的写字\");<br>}</p></code></pre><p>重写的特点：方法名一样，访问修饰符权限不小于父类，返回类型一致，参数列表一致。</p><h1>多态</h1><p>具有三个条件：1、继承 2、重写 3、父类对象引用指向子类对象。同一消息可以根据发送对象的不同而采用多种不同的行为方式。<br></p><ul>\n</ul><p>具体的实现方式就是：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p><p><br></p>',1,'Beloya','2018-07-14 11:28:09','Beloya','2018-07-14 04:33:08',0,140,0,1),
  (17,'菜鸟学习设计模式系列-多态、接口和抽象类','<blockquote>多态是同一个行为具有多个不同的表现形式和行为<br>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</blockquote><h2>动态绑定</h2><div><div><blockquote>静态绑定和动态绑定<br><strong>这里所谓的绑定，即一个方法的调用与方法所在的类（方法主体）关联起来。<br></strong><strong>静态绑定（前期绑定）</strong>：即在程序执行前，即编译的时候已经实现了该方法与所在类的绑定，像C就是静态绑定。<br>java中只有static，final，private和构造方法是静态绑定，其他的都属于动态绑定，而private的方法其实也是final方法，所以可以看出把方法声明为final，第一可以让他不被重写，第二也可以关闭它的动态绑定。<br><strong>动态绑定（后期绑定）</strong>：运行时根据对象的类型进行绑定，java中的大多数方法都是属于动态绑定，也就是实现多态的基础。<br>java实现了后期绑定，则必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。 也就是说，编译的时候该方法不与所在类绑定，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。java里实现动态绑定的是JVM.</blockquote></div></div><blockquote>类中任何private方法都是final，因为你不能访问一个private方法，所以你不能覆盖它（当你试图覆盖一个private方法时，编译器没有给出错提示，但你并没有覆盖这个方法，你只是创建了一个新的方法而已。）</blockquote><p>动态绑定是实现多态的技术，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><h3>多态的优点</h3><div><blockquote><ul><li>1. 消除类型之间的耦合关系</li></ul><ul><li>2. 可替换性&nbsp;&nbsp;多态对已存在代码具有可替换性。</li></ul><ul><li>3. 可扩充性&nbsp; 多态对代码具有可扩充性。增加新的子类不影响已存在类的多态&nbsp;性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。</li></ul><ul><li>4. 接口性&nbsp;&nbsp;多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。</li></ul><ul><li>5. 灵活性&nbsp;&nbsp;它在应用中体现了灵活多样的操作，提高了使用效率。</li></ul><ul><li>6. 简化性&nbsp; &nbsp;&nbsp;多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</li></ul></blockquote></div><div><h3>多态存在的三个必要条件</h3><blockquote><ul><li>继承</li></ul><ul><li>重写</li></ul><ul><li>父类引用指向子类对象</li></ul></blockquote><h2>例子</h2></div><pre><code>abstract class Animal {  <br>    abstract void eat();  <br>}  <br>  <br>class Cat extends Animal {  <br>    public void eat() {  <br>        System.out.println(\"吃鱼\");  <br>    }  <br>    public void work() {  <br>        System.out.println(\"抓老鼠\");  <br>    }  <br>}  <br>  <br>class Dog extends Animal {  <br>    public void eat() {  <br>        System.out.println(\"吃骨头\");  <br>    }  <br>    public void work() {  <br>        System.out.println(\"看家\");  <br>    }  <br>}</code></pre><p>可替换性：多态对动物的行为，对其他任何子类，如猫、狗，也同样工作。<br>可扩充性：在实现了猫、狗的多态基础上，很容易增添“笔”类的多态性。</p><h1>接口</h1><p>本文以设计模式中的应用为背景来说是一些方法特征的集合</p><div><div><p>提到接口，一般会含有两种不同的含义，</p><blockquote><ul><li>指的是java接口，这是一种java语言中存在的结构，有特定的语法和结构</li></ul><ul><li>指一个类所具有的方法特征的集合，是一种逻辑上的抽象。</li></ul></blockquote><p>前者叫做“java接口”，后者叫着“接口”。例如：java.lang.Runnable就是一个java接口</p><h2>为什么使用接口</h2></div></div><div><div>一个对象需要知道其他的一些对象，并且与其他的对象发生相互的作用，这是因为这些对象需要借住于其他对象的行为以便于完成一项工作。这些关于其他对象的知识，以及对其他对象行为的调用，都是使用硬代码写在类里面的，可插入性几乎为0。如：钢笔中需要钢笔水，钢笔水有不同的颜色：</div><div>钢笔水类：</div><br></div><pre><code>public class PenInk {<br>    //墨水颜色<br>    private String Color;<br><br>    public String getColor() {<br>        return inkColor;<br>    }<br><br>    public void setColor(String Color) {<br>        this.Color = Color;<br>    }<br><br>    public PenInk(String inkColor) {<br>        super();<br>        this.inkColor = inkColor;<br>    }<br><br>}</code></pre><p>钢笔中持有一个墨水类的对象引用：</p><pre><code>public class Fountainpen extends Pen{<br>    //引用持有<br>    PenInk ink =new PenInk(\"black\");<br>    @Override<br>    public void write(String cnt) {<br>        System.out.println(\"钢笔墨水颜色是：\"+ink.getInkColor());<br>        System.out.println(\"这是一支钢笔写的内容，内容是：\"+cnt);<br>    }<br>}</code></pre><div><div>但是这种时候，我们需要换一种颜色怎么办呢？就必须要对Fountainpen中的代码进行修改，将PenInk对象时的Color属性进行更改；现在假如我们有一个具体的类，提供某种使用硬代码写在类中的行为；<br>现在，要提供一些类似的行为，并且可以实现动态的可插入，也就是说，要能够动态的决定使用哪一种实现。一种方案就是为这个类提供一个抽象父类，且声明出子类要提供的行为，然后让这个具体类继承自这个抽象父类。同时，为这个抽象父类提供另外一个具体的子类，这个子类以不同的方法实现了父类所声明的行为。客户端可以动态的决定使用哪一个具体的子类，这是否可以提供可插入性呢？</div><div><div><p>子类1：黑色墨水</p><pre><code lang=\"bash\">public class BlackInk extends PenInk{\n\n    public BlackInk() {\n        super(\"black\");\n    }\n}复制代码</code></pre><p>子类2：蓝色墨水</p><pre><code lang=\"bash\">\npublic class BlueInk extends PenInk{\n\n    public BlueInk() {\n        super(\"blue\");\n    }\n}复制代码</code></pre><p>钢笔类引用：</p><pre><code lang=\"bash\">\npublic class Fountainpen extends Pen{\n    PenInk ink ;\n    //通过构造函数初始化PenInk ，PenInk由具体子类来实现\n    public Fountainpen(PenInk ink) {\n        this.ink = ink;\n    }\n    @Override\n    public void write(String cnt) {\n        System.out.println(\"钢笔墨水颜色是：\"+ink.getInkColor());\n        System.out.println(\"这是一支钢笔写的内容，内容是：\"+cnt);\n    }\n}</code></pre></div></div><div><div><p>调用：</p><pre><code lang=\"bash\">public static void main(String[] args) {\n        /**\n         * 使用黑色墨水子类\n         */\n        Pen pen= new Fountainpen(new BlackInk());\n        pen.write(\"我是一支笔\");\n\n    }</code></pre></div><div><div><p>这种方式确实提供了可动态插入性，但是由于java语言是一个单继承的语言。如果硬要做的话，就只好把这个新的超类加到已有的超类上面，形成超超类的情况，如果这个超超类的位置也已经被占用了，就只好继续向上移动，直到移动到类等级结构的最顶端。这样一来，就使得复杂性大大提升，对于之后的维护的工作量也大大提升，如果某些超类是由一些软件商提供的，可插入性就没有了保证。</p></div><h1>Java 接口</h1></div></div></div><div><p>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。在Java中，定一个接口的形式如下：</p><pre><code>public interface InterfaceName {<br> <br>}</code></pre><p>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p><div><div><h2>接口的一些用法</h2><ul><li>单接口方法：接口中只有一个方法；java语言中有很多但方法接口的使用，Runnalble接口中的run（）方法。<pre><code lang=\"bash\">public interface Runnable {\n  /**\n   * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used\n   * to create a thread, starting the thread causes the object''s\n   * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing\n   * thread.\n   * &lt;p&gt;\n   * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may\n   * take any action whatsoever.\n   *\n   * @see     java.lang.Thread#run()\n   */\n  public abstract void run();\n}复制代码</code></pre></li><li>标识接口：没有任何方法和属性的接口；标识接口不对实现它的类有任何语义上的要求，仅仅是表明实现该接口的类属于一个特定的类型。上面说到的Serializable接口就是一种标识接口。</li></ul><pre><code lang=\"bash\">public interface Serializable {\n}复制代码</code></pre><ul><li>常量接口：用java接口来声明一些常量</li></ul><pre><code lang=\"bash\">package com.glmapper.demo.base;\n\npublic interface MyConstants {\n    public static final String USER_NAME=\"admin\";\n};复制代码</code></pre><p>这样一来，凡是实现这个接口的类都会自动继承这些常量，并且都可以像使用自己的常量一样，不需要再用MyConstants.USER_NAME来使用。</p></div><h2>抽象类</h2></div><div><blockquote>在java语言里面，类有两种，一种是具体类，一种是抽象类。在上面给出的代码中，使用absract修饰的类为抽象类。没有被abstract修饰的类是具体类。抽象类通常代表一个抽象概念，它提供一个继承的出发点。而具体类则不同，具体类可以被实例化，应当给出一个有逻辑实现的对象模板。由于抽象类不可以被实例化，因此一个程序员设计一个新的抽象类，一定是用来被继承的。（不建议使用具体类来进行相关的继承）。</blockquote>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用&nbsp;</div><div>增加<code>abstract</code>修饰符之后，就不能被实例化了，即无法通过<code>new&nbsp;</code>来创建对象。&nbsp;</div><div><blockquote>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。<br>　　包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：<br>　　1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>　　2）抽象类不能用来创建对象；<br>　　3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。<br>　　在其他方面，抽象类和普通的类并没有区别。</blockquote></div></div><p><br></p>',1,'Beloya','2018-07-15 00:40:56',NULL,NULL,0,106,0,1),
  (18,'t1','<p>1</p>',1,'Beloya','2018-07-15 08:57:44',NULL,NULL,-1,0,0,1),
  (19,'123','<p>321</p>',1,'Beloya','2018-07-15 09:05:49',NULL,NULL,-1,9,0,1),
  (20,'什么是HashMap？','<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BLv09zN29R71DQrtOxIvzVAWiaVzM70HdGxEvJYZiauxu60OZDaeHPInw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BEia7lduHtWcaf16ZHYhQqUeia7zNOZjgCbHYYibvG9iaSib7TO9cGmEWhjg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BEicNJsaM4wGiauNEvojsqZYJDxXxFiaJcumFAEmfbZPzD05pAiaJcryPtQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59B3pOymnSAc3Jvr21ibM6XndN0mbAKnz6A07fghmiaRSgqZTLic2qzyXGUw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\">\n\n</p><p><br></p><p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\"></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqqUO6KYNSJy5OOBA9TZjKt0RC8QnoOahl9MSGG01mQk35laaRwmIT4A8IWHnmFFy7vKNicXoJDGibA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGqqUO6KYNSJy5OOBA9TZjKtSKFImWLnRGUNI1Ct4FRoC8ZsX0wflMBqEjJqFdof43317OiaGicydjkA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BxyfO1KEQ6toqFjc1aXzcyYCxRM3hD7vKn2nBS8r4zUVCk7W8ibvt6aA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59B6ibnn7icfY5lZibfzXa7EUeZIDAAdVIXjQXicicTKnFRFdz41T7C8gAia7kQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BDVBB2FsNMTKtfqQRIIKweVw3N8akB7CzRBPvR5XNxRwFjTmlbuJRUw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BAGt3ZSHct37bUVBMSdpEb2S7zVyxxoWRWO9z8ud10UOB9xEpJ4acog/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p>众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做<strong>Entry</strong>。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p><p><br></p><p>HashMap数组每一个元素的初始值都是Null。</p><p><br></p><p></p><p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\"></p><p><br></p><p><br></p><p>对于HashMap，我们最常使用的是两个方法：<strong>Get&nbsp;</strong>和&nbsp;<strong>Put</strong>。</p><p><br></p><p><br></p><h2><strong>1.Put方法的原理</strong></h2><p><br></p><p>调用Put方法的时候发生了什么呢？</p><p><br></p><p>比如调用 hashMap.put(\"apple\", 0) ，插入一个Key为“apple\"的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：</p><p><br></p><p><strong>index =&nbsp; Hash（“apple”）</strong></p><p><br></p><p>假定最后计算出的index是2，那么结果如下：</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2jxYh5D3F0avyBppia3BKHO3EU1HqbdThUMS3H9ejwb7ibu4bUiaOnsXqQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。比如下面这样：</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2q93ezXuibE4fQjQpnDMTVlQgSFJmfsYypdxVibAcQeeLsHUCUd4m7tlg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>这时候该怎么办呢？我们可以利用<strong>链表</strong>来解决。</p><p><br></p><p>HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：</p><p><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm29aBmKLDfHETNia2Lzpuia9tm9IDX5XXue0nGoSgFpUGT0crAS45zICQQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。</p><p><br></p><p><br></p><h2>2.Get方法的原理</h2><p><br></p><p>使用Get方法根据Key来查找Value的时候，发生了什么呢？</p><p><br></p><p>首先会把输入的Key做一次Hash映射，得到对应的index：</p><p><br></p><p>index =&nbsp; Hash（“apple”）</p><p><br></p><p>由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：</p><p><br><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2ibC2cqrGyDNL5ms64Wqia4POibCU97PUNZiaSe2ectdgrBsgkGzKEnFOJw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。</p><p><br></p><p>第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。</p><p><br></p><p>之所以把Entry6放在头节点，是因为HashMap的发明者认为，<strong>后插入的Entry被查找的可能性更大</strong>。</p><p><br></p><p><br></p><p></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2CbhVDcDrRueK3DPdouHZ4DS7kAMu5S670iaIyqvwJxPWX9hInMly0IA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2LdeclTgJO0iceUmBXJfnyruWJqgZxqXXNaRAEbU1YXQ0tZiaAibM7kpuQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2MIicE18BusiaQ71BFuEh1YiaG7SFXDFxgEoSpfRia70FHaq3MU99ZteP0Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2ial1Nlu9LvrJlcyIgsGKqOMib1DhB6hKNvKPicYmnBsCAJeQdCibBADJWQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2DKkI3TwcaWrJ8uV0SmMkl5uEzr7tjWwzMkkeWDXhzRBU0ClIqUmXpw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2ial1Nlu9LvrJlcyIgsGKqOMib1DhB6hKNvKPicYmnBsCAJeQdCibBADJWQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2XibTUFockwC0vsmEDjclv78nY6RRLu1zPmrHricicB96gDvibeI9nttyew/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2ial1Nlu9LvrJlcyIgsGKqOMib1DhB6hKNvKPicYmnBsCAJeQdCibBADJWQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2iaWyialPsp9zYOATdE4LQFDZbe8CKXcEXDjXBaGDzWDf1gcGpQ3X6QWA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2Q5CTxcxmEypgk8okzrPtu6nFyEFhD2lVus0vnFCUH8XnyRZuuT1Ypg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>————————————</p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2A4A6WZSfbP1ibtZkVxhHPp8hP5YUfqdZzj4doicOSWQDbWaPsdhnPuhw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2lTnLAfeImsqjibPSX1qH6xzwHJnTjwL8vVU6nfCW3DJFCB5ibf8DtW8Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2QGjssOAR3yHYQbfcEqR6EAvwSt1YsYVIpiafDOqZ6xW3Hfq7PTicf0fg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2y2qatibxzWNmUBGSoHcEH9k8GibtOQibfnKP53M8TmB0RNJyMbv9GeV0Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>之前说过，从Key映射到HashMap数组的对应位置，会用到一个Hash函数：</p><p><br></p><p><strong>index =&nbsp; Hash（“apple”）</strong></p><p><br></p><p>如何实现一个尽量均匀分布的Hash函数呢？我们通过利用Key的HashCode值来做某种运算。</p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2G40K3Fe6uPae3ALBSLa1KBea1W8z0CKtDSJrDlq6nCorCqC8AUTEAQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><strong>index =&nbsp; HashCode（<strong>Key</strong>） % Length ?</strong></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2H5wBeibohUbV9QLryqy5yqKestmYeStqvIrYFTS9nbwKTR9FXgGGtuA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>如何进行位运算呢？有如下的公式（Length是HashMap的长度）：</p><p><br></p><p><strong>index =&nbsp; HashCode（<strong>Key</strong>） &amp;&nbsp; （<strong>Length&nbsp;</strong>- 1）&nbsp;</strong></p><p><strong><br></strong></p><p>下面我们以值为“book”的Key来演示整个过程：</p><p><br></p><p>1.计算book的hashcode，结果为十进制的3029737，二进制的101110001110101110 1001。</p><p><br></p><p>2.假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111。</p><p><br></p><p>3.把以上两个结果做<strong>与运算</strong>，101110001110101110 1001 &amp;&nbsp;1111 = 1001，十进制是9，所以 index=9。</p><p><br></p><p>可以说，Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。</p><p><br></p><p><br></p><p></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm20ZL5eRA8Ccib9sib2dQTm9QF65Ns0qZ1tU0NV1YUwEt6Da00gHsiaK8aw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2aCXAbxfcCMh3uTGib5OiaPX7zicdAgno4Hkpzjg5f69bk4Pe7qyyeKtsw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>假设HashMap的长度是10，重复刚才的运算步骤：<br></p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm227KadcVO2ibiazRxxfp8HGrEpmvbVljnC3nO3iage9Tv4KMQLKroXxDiaA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>单独看这个结果，表面上并没有问题。我们再来尝试一个新的HashCode&nbsp;&nbsp;101110001110101110&nbsp;<strong>1011&nbsp;</strong>：</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2zBoG2JPLmRReaoxuCglHllvcWdnSyeFU888xyVtOyMSFgdcxynHHpg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>让我们再换一个HashCode&nbsp;101110001110101110&nbsp;<strong>1111&nbsp;</strong>试试&nbsp; ：</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2HsZ2y78wmAMQ36W6VQevTrx8jppNpj5esxCDqmCy5jPT6V1Ya94KjQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p>是的，虽然HashCode的倒数第二第三位从0变成了1，但是运算的结果都是1001。也就是说，当HashMap长度为10的时候，有些index结果的出现几率会更大，而有些index结果永远不会出现（比如0111）！</p><p><br></p><p>这样，显然不符合Hash算法均匀分布的原则。</p><p><br></p><p>反观长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p><p><br></p><p></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2FqQicXzQPo8oW5FIY3CcX5unAAR5GPpNPkibNNfVCX9L6qIArAL2KpdA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><br></p>',10,'Beloya','2018-07-16 08:25:42','Beloya','2018-07-19 09:13:50',0,112,0,1),
  (21,'MySql迁移到debian的各种坑','<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&amp;id=28285910&amp;auto=0&amp;height=66\"></iframe></p><p>前几天发现网站访问速度大大下降，体验极差。去后台看了一眼，好家伙内存占用已经达到95%了。感觉整部机子比蜗牛一样慢。由于机子是腾讯的校园优惠机才1核1G。无奈只能买多一台机子做数据库机。由于新机子也是校园机（都是穷惹的祸），只好挑个比较流畅不占内存的系统，然后在Linux中挑选最后相中了debian，因为整个系统基础核心非常小，不仅稳定，而且占用硬盘空间和内存小。</p><p>然后在配置MySQL遇到了各种坑<img src=\"http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/7a/shenshou_thumb.gif\" alt=\"[草泥马]\" data-w-e=\"1\">，网上资料也是有各种问题，折腾巨久。所以记录下来。</p><p>MySQL安装</p><pre><code>sudo apt install mysql-server</code></pre><p>这句安装语句安装不再是MySQL的安装而是被默认替换成MariaDB</p><p>如果是要安装MySQL请用</p><pre><code>wget https：// dev.mysql.com/get/mysql-apt-config_0.8.7-1_all.deb\n<p>sudo dpkg -i mysql-apt-config_*.deb</p></code></pre><p>在弹出页面上，选择所需的版本。</p><p><img src=\"https://files.programster.org/tutorials/debian-9-install-mysql/01.png\" alt=\"\"></p><p>然后使用以下命令安装MySQL服务器（它将安装您选择的版本）。</p><pre><code>sudo apt update<br> sudo apt install mysql-community-server -y</code></pre><p>安装好后要配置文件才能远程访问</p><p>网上很多资料都是说修改 /etc/mysql/my.conf的&nbsp;<code>bind-address = 127.0.0.1</code></p><p>但是我找了好久都没找到这句话，后来才发现根本不在这个<code>my.conf</code>文件中</p><p>而是在<code>mysql.conf.d</code></p><p></p><p>将<code>bind-address = 127.0.0.1</code></p><p></p><p>改为<code>bind-address = 0.0.0.0</code></p><p></p><p>或者注释掉，然后</p><blockquote>1. /etc/init.d/mysql stop (停止MySQL运行)<br>2. mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;&nbsp; (以非认证模式启动mysql服务)<br>3. mysql -u root -p mysql&nbsp; （登录mysql）<br>4. 提示输入密码，此时回车就可以了，也就是使用空密码<br>5. GRANT ALL ON *.* TO&nbsp;<a>''root''@''%''</a>&nbsp;IDENTIFIED BY ''your password here'' WITH GRANT OPTION;&nbsp; （此处是授权从任何机器使用root用户访问mysql数据库）<br>需要注意的是5 画删除线滴地方，这里是你mysql root的密码，前提是你用root账户连你的mysql，如果此处出错的话，你将收到以下错误。<br>ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement<br>6. quit;<br>7.&nbsp; /etc/init.d/mysql restart&nbsp;&nbsp; //重新启动mysql服务</blockquote><p></p><p></p><p></p><p></p><p></p><blockquote>然后就可以从远程访问了。</blockquote><p><br></p>',3,'Beloya','2018-07-16 10:21:47','Beloya','2018-07-18 22:53:32',0,101,0,1),
  (22,'菜鸟学习设计模式系列-设计原则','<h3>前言</h3><p>设计原则是提高系统可维护性的同时，也提高系统的可复用性。但熟悉这些原则并不是说你写出的程序就一定灵活、清晰，只是为你优秀的代码之路铺上了一层栅栏，在这些原则的指导下，你才能避免陷入一些常见的代码泥沼，从而让你写出优秀的东西。</p><h2><span style=\"font-weight: bold;\">单一原则(Single Responsibility Principle)</span></h2><h3><div></div><p>单一原则就是让每个类或者接口做好自己的事，尽量不要去干扰其他的。小时候妈妈就常常说做好自己本分的事，单一原则就是这个意思，不参与其他任何逻辑。就像耳机只能用来听，想要唱就要去买个麦克风。注意，单一职责原则并不是一个类只能有一个函数，而是说这个类中的函数所做的工作是高度相关的，也就是高内聚。</p><p><p>基本判断原则， 就是一个特定的类，当确认以后， 它的责任就确定了，不能增加它行为以外的功能。 例如一般我们定义 API 接口的时候，如果这个接口干了很多事情， 就是一些隐含的事情，我们就认为它设计没有遵循单一原则。</p><strong>优点：</strong></p><ul><li><blockquote>类的复杂性降低，实现什么职责都有清晰明确的定义。<br>可读性提高，复杂性降低，那当然可读性提高了。<br>可维护性提高，可读性提高了，那当然更容易维护了。<br>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</blockquote></li></ul></h3><h2><span style=\"font-weight: bold;\">开闭原则(Open-Close Principle)</span></h2><h3><p>对于软件来说永远不变的东西就是“变化”，开闭原则是使我们的软件系统拥抱变化的核心原则之一。对扩展开放，对修改关闭。也就是要变化的时候尽量不改变原代码情况下进行扩展。</p><p>只有在不修改原代码情况下进行扩展才能保证原有功能稳定的前提下完成需求，不然就很容易造成牵一发动全身这种尴尬局面。</p><p>举个百度最多简单工厂的栗子</p><p>我喜欢吃面条，抽象一个面条基类，(接口也可以)，这是产品的抽象类。</p><div><pre>public abstract class INoodles {\n    /**\n     * 描述每种面条啥样的\n     */\n    public abstract void desc();\n}</pre></div><p>先来一份兰州拉面（具体的产品类）：</p><div><pre>public class LzNoodles extends INoodles {\n    @Override\n    public void desc() {\n        System.out.println(\"兰州拉面 上海的好贵 家里才5 6块钱一碗\");\n    }\n}</pre></div><p>程序员加班必备也要吃泡面（具体的产品类）：</p><div><pre>public class PaoNoodles extends INoodles {\n    @Override\n    public void desc() {\n        System.out.println(\"泡面好吃 可不要贪杯\");\n    }\n}</pre></div><p>还有我最爱吃的家乡的干扣面（具体的产品类）：</p><div><pre>public class GankouNoodles extends INoodles {\n    @Override\n    public void desc() {\n        System.out.println(\"还是家里的干扣面好吃 6块一碗\");\n    }\n}</pre></div><p>准备工作做完了，我们来到一家“简单面馆”（简单工厂类），菜单如下：</p><div><pre>public class SimpleNoodlesFactory {\n    public static final int TYPE_LZ = 1;//兰州拉面\n    public static final int TYPE_PM = 2;//泡面\n    public static final int TYPE_GK = 3;//干扣面\n\n    public static INoodles createNoodles(int type) {\n        switch (type) {\n            case TYPE_LZ:\n                return new LzNoodles();\n            case TYPE_PM:\n                return new PaoNoodles();\n            case TYPE_GK:\n            default:\n                return new GankouNoodles();\n        }\n    }\n}</pre></div><p>简单面馆就提供三种面条（产品），你说你要啥，他就给你啥。这里我点了一份干扣面:</p><div><pre>/**\n * 简单工厂模式\n */\n INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK);\n noodles.desc();</pre></div><p>输出：</p><pre><code>还是家里的干扣面好吃 6块一碗</code></pre><p>这样一看是没什么没问题。但是如果吃腻了呢，想要吃点别的面是不是就只能在简单工厂类上修改。</p><p>总之，开闭原则的核心是：</p><blockquote><ul><li>抽象化</li></ul><ul><li>对可变性的封装原则（1.不可变性不应该散落在代码的多处，而应当被封装到一个对象里面；2.一种可变性不应当与另外一种可变性混合在一起）</li></ul></blockquote></h3><h3><span style=\"font-weight: bold;\">里氏替换原则(Liskov Substitution Principle)</span></h3><h3><p>里氏替换原则算是对“开闭”原则的补充，上面也提到，实现“开闭”原则的关键步骤是抽象化，而父类与子类的继承关系就是抽象化的一种具体体现，里氏替换原本质就是继承和多态的应用。继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。<br>摘自java与模式中的定义:如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p><p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p><ul><li><blockquote>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>子类中可以增加自己特有的方法。<br>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</blockquote></li></ul><p>举个栗子</p><ul><li>顶层抽象父类-食物</li><li><pre><code>public abstract class Food{<br>\t//提供一个抽象方法，以供不同子类来进行具体的实现<br>\tpublic abstract void eat();<br>}</code></pre></li></ul><ul><li>具体食物类型-面条</li></ul><pre><code>public class Noodle extends food{<br>\t@Override<br>\tpublic void eat() {<br>\t\tSystem.out.println(\"吃面条\");<br>\t}</code></pre><ul><li>具体食物-兰州拉面</li></ul><pre><code>public class Lanzou extends noodle<br>{<br>\t/**<br>\t * 重写父类方法<br>\t */<br>\t@Override<br>\tpublic void eat(String foodName) {<br>\t\tSystem.out.println(\"吃兰州拉面\");<br>\t}</code></pre><p>main类</p><pre><code>public static void main(String[] args) {<br>\t\t//子类<br>\t\tLanzou lz=new lanzou();<br>\t\tlz.eat();<br>\t\t//父类<br>\t\tNoodle noodle= new noodle();<br>\t\tnoodle.eat();<br>\t\t//顶层父类<br>\t\tFood food= new Food();<br>\t\tfood.eat();<br>\t}</code></pre><p>输出结果：</p><blockquote><div>可以看出<strong>任何父类可以出现的地方，子类一定可以出现</strong>，反过来是不成立的。我的理解是子类通过继承获取的父类的属性和行为，并且子类自身也具有自己的属性和行为；父类可以出现的地方必然是需要用到父类的属性或者行为，而子类都涵盖了父类的这些信息，因此可以做到替换。反过来不行是因为父类在上述的例子中只是充当了一种类型约束，它可能不具有子类的某些特征，因此就无法做到真正的替换。</div></blockquote><p>里氏替换原则是继承复用的基石，只有当子类可以替换掉基类，软件单位的功能不会受到影响时，基类才能被真正的复用，而子类也才能够在基类的基础上增加新的功能。</p></h3><h2><span style=\"font-weight: bold;\">接口隔离原则(Interface Segregation Principle)</span></h2><h3><p>使用多个专用的接口比单一的接口要好，避免过度依赖一个接口。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。一个类对另外一个类的依赖性应当是建立在最小的接口上的。</p><p>举个栗子</p><p>比如我们需要编写一个完成一个产品的一些操作接口。</p><pre><code>public interface ProductService {<br>\t//增加产品<br>\tpublic int addProduct(Product p);<br>\t//删除产产品<br>\tpublic int deleteProduct(int pId);<br>\t//修改产品<br>\tpublic int updateProduct(Product p);<br>\t//查询一个产品<br>\tpublic Product queryProduct(int pId);<br>}</code></pre><p>现在提供了对产品的增删改查功能。但随着需求升级，我们需要可以增加对产品新的批量导入和导出。现在我们加入这两个功能//从excel中批量导入</p><pre><code>public void batchImportFromExcel();<br>//从excel中批量导导出<br>public void batchExportFromExcel();</code></pre><p>但是如果需求不断升级，那么这个接口是不是会越来越大，非常臃肿</p><div>那么我们就需要进行接口隔离，将产品的基本操作如增删改查放在一个接口，将产品订单处理放在一个接口，将产品申购放在一个接口，将批量操作放在一个接口等等...对于每一个接口我们只关心某一类特定的职责，</div><div>这时候是不是觉得跟单一原则非常相似。其实不是的，其一，<em>单一</em>职责要求的是类和接口职责<em>单一</em>,注 重的是职责。而接口隔离原则注重对接口依赖的隔离(换句话说前者针对单个类的,后者针对类之间的依赖耦合关系)。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构。</div><p>通过这种设计，降低了单个接口的复杂度，使得接口的“内聚性”更高，“耦合性”更低。由此可以看出接口隔离原则的必要性。</p></h3><h2><span style=\"font-weight: bold;\">迪米特原则( Law of Demeter)</span></h2><h3><p>迪米特原则（Law of Demeter，缩写LoD）等同于“最少知识原则（Principle of Least Knowledge）”，是一种软件开发的设计指导原则，特别是面向对象的程序设计。</p><p>迪特米法则的几种表述：</p><p></p><blockquote><code>1.只与你直接的朋友们通信<br></code><code><br></code></blockquote><blockquote><code>2.不跟陌生人说话<br></code><code><br></code></blockquote><blockquote><code>3.每一个软件单位对其他的单位都只有最少知识，而且局限于那些与本单位密切相关的软件单位</code></blockquote><p></p><p></p><p>通俗地讲，一个类应该对自己需要耦合或者调用的类知道得最少，这有点类似于接口隔离原则中的最小接口的概念。类的内部如何实现、如何复杂都与调用者或者依赖者没有关系，调用者或者依赖者只需要知道它需要它需要的方法即可，其他的一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p></h3><h1><span style=\"font-weight: bold;\">依赖倒转原则</span></h1><div>电脑在以前维修的话是根本不可能的事，可是现在却特别容易，比如说内存坏了，买个内存条，硬盘坏了，买个硬盘换上。为啥这么方便？从修电脑里面就有面相对象的几大设计原则，比如单一职责原则，内存坏了，不应该成为更换CPU的理由，它们各自的职责是明确的。再比如开放－封闭原则，内存不够只要插槽足够就可以添加。还有依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，说白了，就是要针对接口编程，不要对实现编程，无论主板，CPU，内存，硬盘都是针对接口设计的，如果是针对实现来设计，内存就要对应的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。\n\n</div><p><span style=\"color: rgb(194, 79, 74);\">依赖倒转原则：要依赖与抽象，不依赖于具体实现。\n\n</span></p><div><div><p>怎么理解呢?<br></p>\n<ul>\n<li>\n<p>1）高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。换言之，模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</p>\n</li>\n<li>\n<p>2）接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。这一点其实不用多说，很好理解，“面向接口编程”思想正是这点的最好体现</p>\n</li>\n</ul>\n<p>首先是第一点，从复用的角度来说，高层次的模块是设计者应当复用的。但是在传统的过程性的设计中，复用却侧重于具体层次模块的复用。比如算法的复用，数据结构的复用，函数库的复用等，都不可避免是具体层次模块里面的复用。较高层次的结构依赖于较低层次的结构，然后较低层次的结构又依赖于更低层次的结构，直到依赖到每一行代码为止。然后对低层次修改也会逐层修改，一直到最高层的设计模块中。</p>\n<p><code>对于一个系统来说，一般抽象层次越高，它的稳定性就越好，因此也是作为复用的重点</code>。</p>\n<p>“倒转”，实际上就是指复用应当将复用的重点放在抽象层上，如果抽象层次的模块相对独立于具体层次模块的话，那么抽象层次的模块的复用便是相对较为容易的了。</p>\n<p></p><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/10/1603e7d16270426f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>\n在很多情况下，一个java程序需要引用一个对象，如果这个对象有一个抽象类型的话，应当使用这个抽象类型作为变量的静态类型。\n在上面我们画了动物和小狗的类图关系，在客户端调用的时候有三种方式：<p></p>\n<pre><code lang=\"bash\"><p>Lanzou lz=new lanzou();<br>\t\tlz.eat();<br>\t\t//父类<br>\t\tNoodle noodle= new noodle();<br>\t\tnoodle.eat();<br>\t\t//顶层父类<br>\t\tFood food= new Food();<br>\t\tfood.eat();</p></code></pre><p>如果我们需要一个兰州拉面的话，我们不应当使用方式1，而是应当使用方式2或者方式3。</p></div></div><h2><span style=\"font-weight: bold;\">总结（明天继续）</span></h2><h3><p></p><div><p>设计原则部分也快写完了还差一个依赖倒置。小结一下：</p><ul><li><blockquote><ol><li>单一职责原则要做到职责单一，高内聚；</li></ol><ol start=\"3\"><li>里氏替换原则要求不要去破坏继承系统；</li><li>依赖倒置原则要求面向接口编程；</li></ol><ol start=\"4\"><li>接口隔离原则要求在设计接口的时候要精简单一；</li></ol><ol start=\"5\"><li>迪米特法则要求要降低耦合；</li></ol><ol start=\"6\"><li>开闭原则是总纲，要求对扩展开发，对修改关闭。</li></ol></blockquote></li></ul><br></div></h3><p><br></p>',1,'Beloya','2018-07-17 09:08:05','Beloya','2018-07-19 08:48:53',0,101,0,1),
  (23,'高并发下的HashMap','<p>这一期我们来讲解高并发环境下，HashMap可能出现的致命问题。</p><p><br></p><p><br></p><p></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hTTQjn7jELbPHdW2DPeBeveVURNms9mOTkdBicj3IU3IwXpMaMO9hiat9A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hT7W4e800gre6dt2lNSyPSo3dKjANxxIl0qe3sLyhRywDm9LtEfXiaD5A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hTknJ0NibtU4qiawHE0cf1SVnjKfEl7L1ZIibenV4v8eKUHyJhzvDrNBefQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hTBSbV3Mx9toL1lpuhMXWpp8SW5h95Lia9kvUaNBSRqHqlv9v2ibh604dQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hT653dDnAqpy9kgcLgaeAiaABwMHCzEhqYzIUJoo3mCgABDeuic6NLqszw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hTeXNo9pciby7bzP827LzBCECCicbmydibhSLxrBQo86Wz7Hmb9mCKRAGbg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。</p><p><br></p><p>这时候，HashMap需要扩展它的长度，也就是进行<strong>Resize</strong>。</p><p><br></p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hTcdyITy7BLOKwx92UkoDsKiaicHkhDHOO4UfLOOQOwQj1CYN3qPsHQrWw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>影响发生Resize的因素有两个：</p><p><strong><br></strong></p><p><strong>1.Capacity</strong></p><p>HashMap的当前长度。上一期曾经说过，HashMap的长度是2的幂。</p><p><br></p><p><strong>2.LoadFactor</strong></p><p>HashMap负载因子，默认值为0.75f。</p><p><br></p><p><br></p><p>衡量HashMap是否进行Resize的条件如下：</p><p><strong><br></strong></p><p><strong>HashMap.Size&nbsp; &nbsp;&gt;=&nbsp; Capacity * L</strong><strong>oadFactor</strong><br></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hTIcb52kGKJwHZSwddr4xe5hibodMN0DdnQKiaxkDibibHiaaT4aBvRicsJhbA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGq6WIag0AtLD9rkIxx4b6hTchr12qEPJN8NePQwW7IQeyEoDHKgaBPZVVKzgNckMLq6e5X9RnBQTQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><strong>1.扩容</strong></p><p>创建一个新的Entry空数组，长度是原数组的2倍。</p><p><br></p><p><br></p><p><strong></strong></p><p><strong>2.ReHash</strong></p><p>遍历原Entry数组，把所有的Entry重新Hash到新数组。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。</p><p><br></p><p>让我们回顾一下Hash公式：</p><p>index =&nbsp; HashCode（<strong>Key</strong>） &amp;&nbsp; （<strong>Length&nbsp;</strong>- 1）&nbsp;</p><p><br></p><p>当原数组长度为8时，Hash运算是和111B做与运算；新数组长度为16，Hash运算是和1111B做与运算。Hash结果显然不同。<br></p><p><br></p><p><br></p><p><strong>Resize前的HashMap：</strong></p><p><strong><br></strong></p><p><strong></strong></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUkXq6HjQRm9T7AnUJSPvIcAMvJT4bOx5nFFicF2UNUNqxpicDlc3OdyrA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><strong>Resize后的HashMap：</strong></p><p><strong><br></strong></p><p><strong></strong></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUHP4iaclQzbfBRN6HiaM1cgb9NHE8FmicnS9O8OhZIUlmphWCtJI9D8heA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><strong></strong><br></p><p><br></p><p><strong>ReHash的Java代码如下：</strong></p><p><strong><br></strong></p><pre>/**<br> * Transfers all entries from current table to newTable.<br> */<br>void transfer(Entry[] newTable, boolean rehash) {<br>    int newCapacity = newTable.length;<br>    for (Entry&lt;K,V&gt; e : table) {<br>        while(null != e) {<br>            Entry&lt;K,V&gt; next = e.next;<br>            if (rehash) {<br>                e.hash = null == e.key ? 0 : hash(e.key);<br>            }<br>            int i = indexFor(e.hash, newCapacity);<br>            e.next = newTable[i];<br>            newTable[i] = e;<br>            e = next;<br>        }<br>    }<br>}</pre><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUYtSzzL57RTqko7GKjrm9HHCmUuGbNxPMMibsF5O1zCOwPkMvIpiaFjrg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUXAn07MGO3eL2oj8ehODPMymaC2masb6qOPqgNQmeicyOS0xM4ZSbk3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUZyXCJp4dNa9SE0btJ4xhLGK1VkBAFACnXhNQRyQnIsea33FibkhdZPg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><strong>注意：下面的内容十分烧脑，请小伙伴们坐稳扶好。</strong></p><p><br></p><p><br></p><p>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：</p><p><br></p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMU2t0XU4TyA5XicIsmVUDzREkp0zVDUJrXu2vaTxWibRMzR5H4SqEu7p0A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUhxYDxjq4m7bohYNNGkovXrEMg7FxQw53zOicDQ4ZlwWOmxRk9oUtgjQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUWPfWOqDJYr1XnIGshVnDHiaxF6R5uwIyqaQvguUDTVGD8vM904ZKiaVA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：</p><p><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUMibL0qESXDy11ciaiafQgNUPib69Hibq65aEXOp6TicmFxdzASuMg0ZPTuzQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：</p><p><br></p><p><strong>e = Entry3</strong></p><p><strong>next = Entry2</strong></p><p><strong><br></strong></p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUX6mkOibHI08IeDMrpwIkzze064vN3QSkzM4NiaB97oU4QjCr72dB82WQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。线程B刚才的状态是：</p><p><br></p><p></p><p><strong>e = Entry3</strong></p><p><strong>next = Entry2</strong></p><p><strong><br></strong></p><p><strong></strong></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMURm5txVYto7KeMEqBCFMFnrvMWUKsGJ9iaYdtubnYVQLLicKH7pXEwgfQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUmlYiaesq6RXwHgUe4OlHgdfkNTWkQjdBDBf7YCkoI2b2HNdiayT3ho5A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且<strong>e指向了Entry2</strong>。此时e和next的指向如下：</p><p><br></p><p><strong>e = Entry2</strong></p><p><strong>next = Entry2</strong></p><p><br></p><p>整体情况如图所示：</p><p><br></p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUbEswmkI5IB9pWN1icQicgc9OI43DDFDpfJYNyBoSAoSWhTd8wXgo672A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>接着是新一轮循环，又执行到红框内的代码行：</p><p><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUMibL0qESXDy11ciaiafQgNUPib69Hibq65aEXOp6TicmFxdzASuMg0ZPTuzQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><strong>e = Entry2</strong></p><p><strong>next = Entry3</strong></p><p><br></p><p>整体情况如图所示：</p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUa9lFFgXjyXyjjCaqLr1flwSfhibGxHTmicqF3tAbP8mcV3AkESNfGUmA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p></p><p><br></p><p><br></p><p>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：<br></p><p><br></p><p></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMU8LrBibB3knlnicvzdZiaZBVBQ46JR6RcpoAZcWcFhSian7OYnyvPkKtiafg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p></p><p><br></p><p>整体情况如图所示：</p><p><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUKUia9GibVO9yGymsvgyGau4u3RBCyyLNJiaPodqXic9HQTQ3OWfeRW9ElA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>第三次循环开始，又执行到红框的代码：</p><p><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUMibL0qESXDy11ciaiafQgNUPib69Hibq65aEXOp6TicmFxdzASuMg0ZPTuzQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><strong><br></strong></p><p><strong>e = Entry3</strong></p><p><strong>next = Entry3.next = null</strong></p><p><strong><br></strong></p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：</p><p><br></p><p><strong></strong></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUFVwF96zYkrqqctnicPEhNsJfChKFib2KiaLLxCpLTueCzKlSnUic9jXhGg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><strong></strong></p><p><strong>newTable[i] =<strong>&nbsp;Entry2</strong></strong></p><p><strong>e = Entry3</strong></p><p><strong><strong><strong>Entry2.next = Entry3</strong></strong></strong></p><p><strong>Entry3.next = Entry2</strong></p><p><strong><br></strong></p><p><strong>链表出现了环形！</strong></p><p><strong><br></strong></p><p>整体情况如图所示：</p><p><br></p><p><br></p><p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUngRBAIib2JtvLxZmJ1RczUPBUyzhj29NQYTExc08dofojLdwVkYYQPA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入<strong>死循环</strong>！</p><p><br></p><p>这种情况，不禁让人联想到一道经典的面试题：</p><p><br></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653189798&amp;idx=1&amp;sn=c35c259d0a4a26a2ee6205ad90d0b2e1&amp;chksm=8c99047cbbee8d6a452fbb171133551553a825c83fb8b0cc66210dcda842c61157a07baaeb6b&amp;scene=21#wechat_redirect\" target=\"_blank\">漫画算法：如何判断链表有环？</a><br></p><p><br></p><p></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUBac5jppEHIvMtAstEdQWibjBRiaQ03jhiacP4EF4sHemPBMVn6KDkU5LQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUhqrw7MUwUsjL4J7AKmG2mMazYcpjXOeJW4K5icZ0COBJ3xdiaArd37Zw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUsKeUc80Yzl2vav6DmwLf6G71af1gGZVIZ8D7r2F7wUG2wicKZUEvmdA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUFSj6giboBgVia8pGYKiaGWvfTLhyfkmibMl2mPvIGG2YnOdQASNYF2JWXQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/NtO5sialJZGplAChQkeJdasPqCPaoiaFMUkL0tqUtblia2BeaWKNmHMkHBEx1BCkkTR8QraSGw7BkG23dTCNWbbvg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"></p><p><br></p><p><br></p><p><strong>1.Hashmap在插入元素过多的时候需要进行Resize，Resize的条件是</strong></p><p><strong><strong>HashMap.Size&nbsp; &nbsp;&gt;=&nbsp; Capacity * L</strong><strong>oadFactor。</strong></strong></p><p><strong><strong><br></strong></strong></p><p><strong><strong>2.<strong>Hashmap的</strong>Resize包含扩容和ReHash两个步骤，ReHash在并发的情况下可能会形成链表环。</strong></strong></p><p><br></p><p><br></p>',10,'Beloya','2018-07-19 09:16:27',NULL,NULL,0,91,0,1),
  (24,'菜鸟学习设计模式系列-单例模式','<h2>设计模式的分类</h2><div><p>总体来说设计模式分为三大类：</p><blockquote>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</blockquote><p>单例模式可以说是所有设计模式的中最简单的模式。如果你希望你的工程中只实例化一次那么你就最好选择它。单例模式确保被创建的类只有一个实例对象，而且自行实例化并向整个系统提供这个实例。一般情况下我们称当前这个类为单例类。</p><p>单例模式有三个特点</p><blockquote><ul><li>1、单例类只能有一个实例。</li></ul><ul><li>2、单例类必须自己创建自己的唯一实例。</li></ul><ul><li>3、单例类必须给所有其他对象提供这一实例。</li></ul></blockquote><div>单例模式有5种实现方式</div></div><p>懒汉式、饿汉式、静态内部类、双重校验、枚举</p><p>它们的区别</p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th>&nbsp;</th><th>&nbsp;&nbsp;线程安全</th><th>&nbsp;&nbsp;并发性能好</th><th>&nbsp;&nbsp;可以延迟加载</th><th>序列化/反序列化安全&nbsp;&nbsp;&nbsp;</th><th>能抵御反射攻击&nbsp;&nbsp;&nbsp;</th></tr><tr><td>&nbsp;&nbsp;饿汉式</td><td>&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;&nbsp;懒汉式（加锁）</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;&nbsp;懒汉式（不加锁）</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;&nbsp;静态内部类</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;&nbsp;双重校验</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;&nbsp;枚举</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;</td><td>&nbsp;&nbsp;&nbsp;√</td><td>&nbsp;&nbsp;&nbsp;√</td></tr></tbody></table><h2><strong>方式一：饿汉式</strong></h2><pre><code>public class SingleObject {<br> <br>   //创建 SingleObject 的一个对象<br>   private static SingleObject instance = new SingleObject();<br> <br>   //让构造函数为 private，这样该类就不会被实例化<br>   private SingleObject(){}<br> <br>   //对外提供一个获取实例的方法<p>// 满足要点：向整个系统提供这个实例</p>   public static SingleObject getInstance(){<br>      return instance;<br>   }<br>}</code></pre><h2><strong>方式二：懒汉式（不加锁）</strong></h2><pre><code>public class SingleObject {<br> <br>   //创建 SingleObject 的一个对象<br>   private static SingleObject instance =null;<br> <br>   //让构造函数为 private，这样该类就不会被实例化<br>   private SingleObject(){}<br> <br>   //对外提供一个获取实例的方法<br>// 满足要点：向整个系统提供这个实例<br><br>   public static SingleObject getInstance(){<br> if (instance == null) {  <br>       instance=new SingleObject() ;<br>}<br>   return new instance;<br>   }<br>}</code></pre><div><div>两个线程几乎同时调用&nbsp;<code>getInstance()</code>&nbsp;第一个进入的线程判断&nbsp;<code>instance</code>&nbsp;为空，开始走这一行&nbsp;<code>instance = new Singleton();</code>。,<strong>注意，是开始走这一行，并未完成实例化！</strong>&nbsp;此时第二个线程也走到&nbsp;<code>if (instance == null)</code>此时判断也为空。那么 这两个线程都会得到一个新的实例，那么就产生两个实例。那么还怎么单例？</div></div><h2><strong>方式三：懒汉式（加锁）</strong></h2><pre><code>public class SingleObject {<br> <br>   //创建 SingleObject 的一个对象<br>   private static SingleObject instance =null;</code><code> <br>   //让构造函数为 private，这样该类就不会被实例化<br>   private SingleObject(){}<br> <br>   //对外提供一个获取实例的方法<br>// 满足要点：向整个系统提供这个实例<br><br>   public static synchronized SingleObject getInstance(){<br> if (instance == null) {  <br>       instance=new SingleObject() ;<br>}<br>   return new instance;<br>   }<br>}</code></pre><p>加一个<code>synchronized</code>同步就能实现线程安全的单例模式，但是这样搞的话，我们每次进来都可能要同步一下。多数时候我们并不是两个或多个线程同时来访问，我们并不需要去同步。这样做其实造成了不必要的开销。</p><h2><strong>方式三：静态内部类</strong></h2><p>我反手又是一串代码</p><pre><code>public class Singleton {  <br>    private static class SingletonHolder {  <br>    private static final Singleton INSTANCE = new Singleton();  <br>    }  <br>    private Singleton (){}  <br>    public static final Singleton getInstance() {  <br>    return SingletonHolder.INSTANCE;  <br>    }  <br>}</code></pre><p>看到这，可能有人会对静态内部类为什么是线程安全有疑问</p><p>在这个例子中内部类 SingletonPatterHolder 的静态变量 singletonPattern，这个变量是我们需要的那个单例，即外部类 SingletonPattern 的对象，就是那个我们需要的唯一的对象。</p><p>当我们调用 SingletonPattern.getInstance() 时，内部类 SingletonPatternHolder 才会初始化，静态变量 singletonPattern 被创建出来。</p><blockquote><p>这个实现思路中最主要的一点就是利用类中静态变量的唯一性。</p></blockquote><h2><strong>方式三：双重校验</strong></h2><div><pre><code>public class Singleton {  <br>    private volatile static Singleton singleton;  <br>    private Singleton (){}  <br>    public static Singleton getSingleton() {  <br>    if (singleton == null) {  <br>        synchronized (Singleton.class) {  <br>        if (singleton == null) {  <br>            singleton = new Singleton();  <br>        }  <br>        }  <br>    }  <br>    return singleton;  <br>    }  <br>}</code></pre><p>注意这里的singleton 使用了volatile进行修饰，为什么要用这个修饰呢，虽然这种双重校验方式看上去是线程安全的，但实际上单单是<code>instance = new Singleton()</code></p><p></p><p>这一句都包含了好多动作，他并不是原子操作，它会做以下动作</p><p></p><blockquote><li>1.给<code>instance</code>分配内存</li><li>2.调用&nbsp;<code>Singleton</code>的构造函数，来初始化成员变量</li><li>3.将<code>instance</code>对象指向分配的内存空间（执行完这步 instance 就不为 null 了）</li></blockquote><ol><li><blockquote>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</blockquote></li></ol><div>解决方法也很简单:加上&nbsp;<code>volatile</code>&nbsp;就可以了。volatile一般用于多线程的可见性，但是这里是用来防止指令重排序的。所以volatile在某些特定场景是可以保证有序性。</div><div><h3 id=\"-\">枚举单例</h3><blockquote><p>《Effective Java》:单元素的枚举类型已经成为实现Singleton的最佳方法</p></blockquote></div><div><pre><code>public enum Singleton {<br>     //理解为 public static final Singleton INSTANCE;<br>     INSTANCE;<br> }</code></pre><p>实例化：<code>Singleton.INSTANCE</code>&nbsp;就是这么简单。</p><p>但是单例这样用的人我觉得还是不多。猜想是大家对枚举了解不太多吧。如果看到枚举这个方式一脸懵B，就看看枚举相关的知识。反正我一开始也是一脸懵逼o((⊙﹏⊙))o</p></div><div><h2>JAVA中的单例模式使用</h2></div></div><div><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/23/160822319952bbf9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/23/16082235b1827b2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"></figure><figure>每个Java应用程序都有一个Runtime类的单个实例，允许应用程序与运行应用程序的环境进行交互。 当前运行时可以从getRuntime方法获得。应用程序不能创建它自己的这个类的实例。</figure><figure>相信看完上面的都知道RunTime是用什么方式创建的了吧</figure><figure><div><h2>Spring中的单例</h2><p>Spring依赖注入Bean实例默认是单例的。Spring中bean的依赖注入都是依赖AbstractBeanFactory的getBean方法来完成的。那我们就来看看在getBean中都发生了什么。</p><p><strong>org.springframework.beans.factory.suppor.AbstractBeanFactory</strong></p><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/23/1608240b1b8b27b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>从上面这张图中我们啥也看不出，只知道在getBean中又调用了doGetBean方法（Spring中还有java源码中有很多类似的写法，好处在于我们可以通过子类继承，继而编写我们自己的处理逻辑）。OK，再来看看doGetBean方法。<p></p><p></p><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/23/16082466281582ea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>来看下这个方法的注释：<strong>返回指定的bean可以共享或独立的实例</strong>&nbsp;（谷歌+有道+百度）<p></p><ul><li>name:要检索的bean的名称</li><li>requiredType:要检索的bean所需的类型</li><li>args:如果使用静态工厂方法的显式参数创建原型，则使用参数。 在其他情况下使用非空args值是无效的。</li><li>typeCheckOnly:获得实例是否是为了类型检查，而不是实际的使用</li></ul><p>这个方法体内的代码非常的多，那么我们本文不是来学习Spring的，所以我们只看我们关心的部分，</p><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/23/160824f12ec92598?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><strong>为手工注册的singleton检查单例缓存。</strong>,从这个注释可以看出，此处就是我们获取实例的地方，再往下看。<p></p><p>此处和上面的getBean一样，也是通过模板方法的方式进行调用的。</p><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/23/1608251887dbdedd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>OK，这里我们看到了获取单例实例的具体实现过程。&nbsp;<strong>返回注册在给定名称下的(原始的)singleton对象。检查已经实例化的单例，并且还允许提前引用当前创建的单例（解析循环引用）。</strong><figure><img src=\"https://user-gold-cdn.xitu.io/2017/12/23/1608251b22075527?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure>这里使用的是饿汉式中的双重检测机制来实现的。</div></figure><h2><figure><span style=\"font-weight: bold;\">扩展:</span></figure></h2><figure><h3><span style=\"font-weight: bold;\">为什么需要volatile？volatile有什么用？</span></h3><blockquote><ul><li>首先要回答可见性，这个是毋庸质疑的，然后可能又会考到java内存模型。</li></ul><ul><li>防止指令重排序: 防止new Singleton时指令重排序导致其他线程获取到未初始化完的对象。instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。1.给 instance 分配内存2.调用 Singleton 的构造函数来初始化成员变量3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。</li></ul><ul><li>顺便也可以说下volatie原理用内存屏障</li></ul></blockquote><h3><span style=\"font-weight: bold;\">讲讲synchronized和volatile的区别</span></h3><p>这里可以从synchroized能保证原子性，volatile不能保证说起，以及讲下synchroized是重量级锁，甚至可以所以下他和Lock的区别等等。</p><h3><span style=\"font-weight: bold;\">线程安全一般怎么实现的?</span></h3><ul><li>互斥同步。如lock,synchroized</li><li>非阻塞同步。如cas。</li><li>不同步。如threadLocal,局部变量。</li></ul><h2><span style=\"font-weight: bold;\">枚举类</span></h2><pre><code lang=\"bash\">public enum Singleton{\n    INSTANCE;\n}<br></code></pre><p>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。同时他也是《Effective Java》中推荐的模式。最后通过枚举类，他能自动避免序列化/反序列化攻击，以及反射攻击(枚举类不能通过反射生成)。</p></figure><br></div>',1,'Beloya','2018-07-20 10:55:28',NULL,NULL,0,95,0,1),
  (25,'为什么要用枚举实现单例模式','<p>看过我的上篇设计模式-单例模式中在文中最后讲了单例模式的枚举方式，都知道《Effective Java》:单元素的枚举类型已经成为实现Singleton的最佳方法</p><blockquote>因为在《Effective Java》中有提到，因为其功能完整、使用简洁、无偿地提供了序列化机制、在面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点，单元素的枚举类型被作者认为是实现Singleton的最佳方法。</blockquote><p>但是上篇文章中说的很笼统，于是决定结合Joshua Bloch的《effective java》写一篇总结下</p><p>&nbsp;&nbsp;如果不使用枚举，大家采用的一般都是“双重检查加锁”这种方式，如下</p><pre><code>public class Singleton {  <br>    private volatile static Singleton singleton;  <br>    private Singleton (){}  <br>    public static Singleton getSingleton() {  <br>    if (singleton == null) {  <br>        synchronized (Singleton.class) {  <br>        if (singleton == null) {  <br>            singleton = new Singleton();  <br>        }  <br>        }  <br>    }  <br>    return singleton;  <br>    }  <br>}</code></pre><p><br></p><h1>为什么要用枚举单例</h1><div><p>私有化构造器并不保险</p><p>&nbsp;《effective java》中只简单的提了几句话：“享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要低于这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。</p><p>举个获取双重校验的栗子：</p><pre><code>Singleton s=Singleton.getInstance();<br>        Singleton sUsual=Singleton.getInstance();<br>        Constructor&lt;Singleton&gt; constructor=Singleton.class.getDeclaredConstructor();<br>        constructor.setAccessible(true);<br>        Singleton sReflection=constructor.newInstance();<br>        System.out.println(\"正常情况下，实例化两个实例是否相同：\"+(s==sUsual));<br>        System.out.println(\"反射单例模式情况下，实例化两个实例是否相同：\"+(s==sReflection));</code></pre><p>这时候输出结果如下</p><pre><code>正常情况下，实例化两个实例是否相同：true<br>通过反射攻击单例模式情况下，实例化两个实例是否相同：false</code></pre><p>这时候就出现发射被攻击的问题，不过这个可以加个异常处理就可以解决，但除了这个问题它还存在序列化的问题</p><p>在单例中<code>implements Serializable</code>之后</p><pre><code>SerSingleton s = SerSingleton.getInstance();<br>        s.setContent(\"单例序列化\");<br>         System.out.println(\"序列化前读取其中的内容：\"+s.getContent());<br>        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"SerSingleton.obj\"));<br>         oos.writeObject(s);<br>       oos.flush();<br>         oos.close();<br>        FileInputStream fis = new FileInputStream(\"SerSingleton.obj\");<br>         ObjectInputStream ois = new ObjectInputStream(fis);<br>         SerSingleton s1 = (SerSingleton)ois.readObject();<br>       ois.close();<br>         System.out.println(\"序列化后读取其中的内容：\"+s1.getContent());<br>        System.out.println(\"序列化前后两个是否同一个：\"+(s==s1));</code></pre><p>它输出的结果：</p><pre><code>序列化前读取其中的内容：单例序列化<br>序列化后读取其中的内容：单例序列化<br>序列化前后两个是否同一个：false</code></pre><p>这时候会出现两个对象并不相等。因为任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。</p><p>当然，这个问题也是可以解决的，加入<code>readResolve()</code>就可以了</p><p>这时候完整代码如下：</p><pre><code>public class Singleton implements Serializable{  </code><code>    private volatile static Singleton singleton;  <br>    private Singleton (){}  <br>    public static Singleton getSingleton() {  <br>    if (singleton == null) {  <br>        synchronized (Singleton.class) {  <br>        if (singleton == null) {  <br>            singleton = new Singleton();  <br>        }  <br>        }  <br>    }  <br>    return singleton;  <br>    }  \n<p> private Object readResolve(){<br>        System.out.println(\"read resolve\");<br>        return instance;<br></p>    }//如果被反序列化的对象的类存在readResolve这个方法，他会调用这个方法来返回一个“array”，然后浅拷贝一份，作为返回值，并且无视掉反序列化的值，即使那个字节码已经被解析。 <br>\n}</code></pre><p>不过还是最推荐采用枚举来实现单例，想详细了解的同学可以翻看《effective java》第77条：对于实例控制，枚举类型优于readResolve。</p><h3>枚举类详解</h3><div>先来重温一下实现方式</div><div><pre><code>public enum Singleton { <br>INSTANCE; <br>private Singleton() {} <br>}</code></pre><p>看上去挺简单的，实际上编译之后是</p><pre><code>public final class  Singleton extends Enum&lt; EnumSingleton&gt; {<br>        public static final Singleton INSTANCE; <br>public static Singleton[] values(); <br>public static Singleton valueOf(String s); <br>static {}; <br>}</code></pre><blockquote>Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。&nbsp;<br>在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。&nbsp;<br>也就是说，以下面枚举为例，序列化的时候只将&nbsp;&nbsp;Singleton&nbsp;这个名称输出，反序列化的时候再通过这个名称，查找对于的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。</blockquote><p>由此可知，枚举天生保证序列化单例。</p></div><p><br></p></div><p><br></p>',1,'Beloya','2018-07-22 03:04:35',NULL,NULL,0,153,0,1),
  (26,'菜鸟学习设计模式系列-工厂模式','<p>本来是<span style=\"font-weight: bold;\"></span>周末的时候打算写的，奈何公司周五和周六要加班调试BUG，对此我是持坚决反对以及强烈抗议的坚决态度的，并且对此行为是强烈谴责。然后老老实实去加班了。</p><p>这个系列上篇写的是单例模式，也列举了枚举单例的优势，这回就来聊聊工厂模式。</p><p>工厂模式具有以下三种形态：</p><blockquote><ul><li>简单工厂模式：又称静态工厂模式</li></ul><ul><li>工厂方法模式：又称多态性工厂模式或者虚拟构造子模式</li></ul><ul><li>抽象工厂模式：又称工具箱模式</li></ul></blockquote><h2 id=\"简单工厂模式-Simple-Factory-Pattern\"><span style=\"font-weight: bold;\">简单工厂模式(Simple Factory Pattern)</span></h2><div>简单工厂类可以根据不同参数返回不同实例</div><p>简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</strong>\n\n</p><p>简单工厂模式结构比较简单，其核心是工厂类的设计\n\n</p><p><img src=\"https://user-gold-cdn.xitu.io/2017/12/24/160864d040dbd467?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n</p><h3 id=\"实例\">实例</h3><blockquote><p>我去商店买水果，老板很懒，让我自己去拿（工厂类）</p></blockquote><pre><code>public interface Fruits {\n\t/**\n\t * 描述\n\t */\n\tpublic void describe();\n}</code></pre><p>具体产品-苹果</p><pre><code>public class Apple implements Fruits {<br>\tpublic void describe() {<br>\t\tSystem.out.println(\"苹果\");<br>\t};<br>}</code></pre><p>具体产品-香蕉</p><pre><code>public class Banana implements Fruits {<br>\tpublic void describe() {<br>\t\tSystem.out.println(\"香蕉\");<br>\t}<br>}</code></pre><p>工厂角色-水果商店</p><pre><code>public class FruitsFactory {<br>\t/**<br>\t * 获取苹果<br>\t * @return Apple<br>\t */<br>\tpublic static Apple createApple(){<br>\t\treturn new Apple();<br>\t}<br>\t/**<br>\t * 获取香蕉<br>\t * @return Banana<br>\t */<br>\tpublic static Banana createBanana(){<br>\t\treturn new Banana();<br>\t}<br>}</code></pre><p><span style=\"font-weight: bold; font-size: large;\">测试</span></p><pre><code>public class Test {<br>\tpublic static void main(String[] args) {<br>\t\tFruits apple = FruitsFactory.createApple();<br>\t\tapple.describe();<br>\t\tFruits banana = FruitsFactory.createBanana();<br>\t\tbanana.describe();<br>\t}<br>}</code></pre><p><span style=\"font-weight: bold; font-size: medium;\">输出：</span></p><blockquote>苹果<br>香蕉</blockquote><p><span style=\"font-size: large;\">好</span><span style=\"font-size: large;\">了这就完了，就这么简单。</span></p><h3 id=\"小结\"><span style=\"font-weight: bold;\">小结</span></h3><div><div><blockquote><code>优点：模式的核心是工厂类，这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。而客户端则可以免除直接创建产品对象的责任，而仅仅负责消费产品即可。用一句话来说就是：简单工厂模式这个做法实现了对责任的分割。<br></code><code>缺点：集中了所有产品的创建逻辑，形成了一个无所不能的全职类，但是之前我们在讨论设计原则的时候说过，我们要尽量避免这种情况的发生，这种就很明显破坏了单一职责这条原则，另外也不满足开闭原则的约束。当我们需要进行品类扩展时，我们需要不断的去修改我们的工厂的业务逻辑，一方面是工厂类会急速的膨胀，另一方面因为囊括了不同的产品对于我们后期的维护造成一定的影响。</code></blockquote></div><h2 id=\"工厂方法模式-Factory-Method-Pattern\"><span style=\"font-weight: bold;\">工厂方法模式(Factory Method Pattern)</span></h2></div><blockquote>在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。<br>此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，违背了单一职责，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。\n\n</blockquote><p>在工厂方法模式中，我们<span style=\"color: rgb(194, 79, 74);\"><strong>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构</strong>。</span>\n\n</p><p><img src=\"https://user-gold-cdn.xitu.io/2017/12/24/1608709a15936dea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n</p><p>&nbsp;在工厂方法模式结构图中包含如下几个角色：</p><blockquote>&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp;&nbsp;&nbsp;●&nbsp;Product（抽象产品）：</strong>它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp; ●&nbsp;ConcreteProduct（具体产品）：</strong>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp; ●&nbsp;creator（抽象工厂）：</strong>在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。<br>&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp;&nbsp; ●&nbsp;Concrete</strong><span style=\"font-weight: bold;\">C</span><strong>reator</strong>&nbsp;&nbsp;<strong>（具体工厂）：</strong>它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</blockquote><pre><code>public interface Fruits {<br>\t/**<br>\t * 抽象产品<br>\t */<br>\tpublic void describe();<br>}</code></pre><pre><code>public interface FruitsFactory {<br>\t/**<br>\t * 抽象工厂<br>\t */<br>\tpublic void createFruits();<br>}</code></pre><pre><code>public class Banana implements Fruits {\n<p>/**<br>\t * 具体产品<br></p>\t */\n\tpublic void describe() {<br>\t\tSystem.out.println(\"香蕉\");<br>\t}<br>}</code></pre><pre><code>public class Apple implements Fruits {\n<p>/**<br>\t * 具体产品<br><br></p>\t */\tpublic void describe() {<br>\t\tSystem.out.println(\"苹果\");<br>\t};<br>}</code></pre><pre><code>public interface AppleFactory {<br>\t/**<br>\t * 具体工厂-苹果<br>\t */<br>\tpublic void createFruits(){\nreturn new Apple();<br>\n}<br>}</code></pre><pre><code>public interface BananaFactory {<br>\t/**<br>\t * 具体工厂-苹果<br>\t */<br>\tpublic void createFruits(){<br>return new Banana();<br><br>}<br>}</code></pre><p><span style=\"font-size: medium; font-weight: bold;\">测试代码：</span></p><pre><code>public static void main(String[] args) {<br>        FruitsFactory fruitsfactory;<br>        Fruits fruits;<br>        fruitsfactory= new AppleFactory();<br>        fruits= fruitsfactory.createFruits();<br>        fruits.describe();<br>        fruitsfactory= new BananaFactory ();<br>        fruits= fruitsfactory.createFruits();<br>        fruits.describe();<br>    }</code></pre><p><span style=\"font-weight: bold; font-size: medium;\">输出结果：</span></p><blockquote>苹果<br>香蕉</blockquote><h3 id=\"小结-1\"><span style=\"font-weight: bold;\">小结</span></h3><blockquote>工厂方法模式是对简单工厂模式的升级应用，它解决了简单工厂模式中工厂类职责繁重的问题，且更符合设计模式的开闭原则，增加新的产品不需要修改原先的代码，只需要增加对应的产品实例及工厂实例即可，同时这也是工厂方法模式的一个缺点，添加新产品，系统中的类就需要成对的增加，一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖，这并不是什么好事。<br>在工厂方法模式中，客户并不需要知道具体产品类创建的细节，只需要关心产品对应的工厂，根据工厂创建自己需要的产品就行了。</blockquote><h2 id=\"抽象工厂模式-Abstract-Factory-Pattern\"><span style=\"font-weight: bold;\">抽象工厂模式(Abstract Factory Pattern)</span></h2><blockquote>&nbsp; 抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</blockquote><p>光看上面定义估计都是一脸懵逼，那就直接上图上代码吧。</p><p>举个栗子</p><blockquote>Sunny软件公司欲推出一款新的手机游戏软件，该软件能够支持Symbian、Android和Windows Mobile等多个智能手机操作系统平台，针对不同的手机操作系统，该游戏软件提供了不同的游戏操作控制(OperationController)类和游戏界面控制(InterfaceController)类，并提供相应的工厂类来封装这些类的初始化过程。软件要求具有较好的扩展性以支持新的操作系统平台，为了满足上述需求，试采用抽象工厂模式对其进行设计。\n\n</blockquote><p>结构图如下\n\n</p><p><img alt=\"\" jj-img-width=\"1244\" jj-img-height=\"1072\" src=\"https://user-gold-cdn.xitu.io/2017/8/30/be58f1c1da8ad4c9e5a7570bd3782f61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n</p><p><span style=\"font-weight: bold; font-size: large;\">代码</span></p><p>抽象工厂代码\n\n</p><pre><code>/抽象工厂接口<br>public interface SysFactory {<br>    InterfaceController createInterface();<br>    OperationController createOperation();<br>}<br>//生产三种不同系统的抽象工厂<br>public class SymbianSysFactory implements SysFactory {<br>    @Override<br>    public InterfaceController createInterface() {<br>        return new SymbianInterfaceController();<br>    }<br>    @Override<br>    public OperationController createOperation() {<br>        return new SymbianOperationController();<br>    }<br>}<br>public class AndroidSysFactory implements SysFactory {<br>    @Override<br>    public InterfaceController createInterface() {<br>        return new AndroidInterfaceController();<br>    }<br>    @Override<br>    public OperationController createOperation() {<br>        return new AndroidOperationController();<br>    }<br>}<br>public class WindowsSysFactory implements SysFactory {<br>    @Override<br>    public InterfaceController createInterface() {<br>        return new WindowsInterfaceController();<br>    }<br>    @Override<br>    public OperationController createOperation() {<br>        return new WindowsOperationController();<br>    }<br>}</code></pre><p><br></p><p>操作控制器代码</p><pre><code>//操作控制器接口<br>public interface OperationController {<br>    void controlOperation();<br>}<br>//生产三种操作控制器接口<br>public class SymbianOperationController implements OperationController {<br>    @Override<br>    public void controlOperation() {<br>        System.out.println(\"使用Symbian系统操作控制\");<br>    }<br>}<br>public class AndroidOperationController implements OperationController {<br>    @Override<br>    public void controlOperation() {<br>        System.out.println(\"使用Android系统操作控制\");<br>    }<br>}<br>public class WindowsOperationController implements OperationController {<br>    @Override<br>    public void controlOperation() {<br>        System.out.println(\"使用Windows Mobile系统操作控制\");<br>    }<br>}</code></pre><p>界面控制器代码\n\n</p><pre><code>//界面控制器接口<br>public interface InterfaceController {<br>    void controlInterface();<br>}<br>//分别生成三种界面控制器<br>public class SymbianInterfaceController implements InterfaceController {<br>    @Override<br>    public void controlInterface() {<br>        System.out.println(\"使用Symbian系统游戏界面控制\");<br>    }<br>}<br>public class AndroidInterfaceController implements InterfaceController {<br>    @Override<br>    public void controlInterface() {<br>        System.out.println(\"使用Android系统游戏界面控制\");<br>    }<br>}<br>public class WindowsInterfaceController implements InterfaceController {<br>    @Override<br>    public void controlInterface() {<br>        System.out.println(\"使用Windows Mobile系统游戏界面控制\");<br>    }<br>}</code></pre><p>测试代码</p><pre><code>public static void main(String[] args) {<br>        SysFactory sysFactory;<br>        InterfaceController interfaceController;<br>        OperationController operationController;<br>        sysFactory = new SymbianSysFactory();<br>        interfaceController = sysFactory.createInterface();<br>        operationController = sysFactory.createOperation();<br>        interfaceController.controlInterface();<br>        operationController.controlOperation();<br>    }</code></pre><p>输出结果</p><blockquote>使用Symbian系统游戏界面控制&nbsp;</blockquote><blockquote>使用Symbian系统操作控制\n\n</blockquote><p><span style=\"color: rgb(194, 79, 74);\">与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式对产品对象进行创建。</span></p><h2><span style=\"font-weight: bold; font-size: medium; color: rgb(0, 0, 0);\">扩展</span></h2><p>&nbsp;为了让系统具备良好的灵活性和可扩展性，我们可以引入工具类XMLUtil和配置文件，其中，XMLUtil类的代码如下所示：\n\n</p><pre><code>public class XMLUtil {<br>//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象<br>\tpublic static Object getBean() {<br>\t\ttry {<br>\t\t\t//创建文档对象<br>\t\t\tDocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();<br>\t\t\tDocumentBuilder builder = dFactory.newDocumentBuilder();<br>\t\t\tDocument doc;\t\t\t\t\t\t\t<br>\t\t\tdoc = builder.parse(new File(\"config.xml\")); <br>\t\t<br>\t\t\t//获取包含类名的文本节点<br>\t\t\tNodeList nl = doc.getElementsByTagName(\"className\");<br>            Node classNode=nl.item(0).getFirstChild();<br>            String cName=classNode.getNodeValue();<br>            <br>            //通过类名生成实例对象并将其返回<br>            Class c=Class.forName(cName);<br>\t  \t    Object obj=c.newInstance();<br>            return obj;<br>        }   <br>        catch(Exception e) {<br>           \te.printStackTrace();<br>           \treturn null;<br>       \t}<br>\t}<br>}</code></pre><p>&nbsp;配置文件config.xml中存储了具体工厂类的类名，代码如下所示：\n\n</p><pre><code>&lt;?xml version=\"1.0\"?&gt;<br>&lt;config&gt;<br>\t&lt;className&gt;AndroidSysFactory&lt;/className&gt;<br>&lt;/config&gt;</code></pre><p>测试代码</p><pre><code>public static void main(String[] args) {<br>        SysFactory sysFactory;<br>        InterfaceController interfaceController;<br>        OperationController operationController;<br>        sysFactory = (SkinFactory)XMLUtil.getBean();<br>        interfaceController = sysFactory.createInterface();<br>        operationController = sysFactory.createOperation();<br>        interfaceController.controlInterface();<br>        operationController.controlOperation();<br>    }</code></pre><p>输出结果</p><blockquote>使用Android系统游戏界面控制&nbsp;</blockquote><blockquote>使用Android系统操作控制\n\n</blockquote><p>&nbsp; 如果需要切换，只需修改配置文件即可，在实际环境中，我们可以<strong>提供可视化界面，例如菜单或者窗口来修改配置文件，用户无须直接修改配置文件</strong>。如果需要增加新的系统，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件即可切换新的，原有代码无须修改，符合“开闭原则”。\n\n</p><h2><span style=\"font-weight: bold;\">小结</span></h2><p>抽象工厂模式是对工厂方法模式的进一步升级使用，使得工厂方式更符合实际开发需求，在实际开发中往往需要一个产品族来完成工作。抽象工厂模式在新增产品族时很方便，无需修改已有系统，符合“开闭原则”。但抽象工厂模式最大的缺点是对于新增产品很麻烦，需要对原有系统进行较大的修改，不符合“开闭原则”。所以在实际开发中，我们需要衡量具体的需求，选择对应的设计模式，对于需要客户端使用同一产品族的需求时，可以选择抽象工厂模式进行设计。</p><p>好了，看个视频放松下</p><p><iframe src=\"//player.bilibili.com/player.html?aid=27580722&amp;cid=47590604&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width:100%;height:556px;\" __idm_id__=\"234384385\"> </iframe></p><p><br></p><p><br></p><p><br></p><p><br></p>',1,'Beloya','2018-07-24 09:47:09','Beloya','2018-07-25 09:06:54',0,113,0,1),
  (27,'MySql8小时断线问题','<p>这几天时不时收到博客的异常邮件，但无奈于最近要赶项目，没时间处理异常也没时间更新博客<img src=\"http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/bc/fuyun_thumb.gif\" alt=\"[浮云]\" data-w-e=\"1\"></p><p>现在难得抽出点时间，查看了一下异常邮件和日志，发现了是MySQL闲置时间超过八小时(谁让我这这么冷清呢)，然后database端就会将此连接单方面废弃。这时如果连接池继续使用之前的连接，就会抛出异常</p><p>MySql有一个系统变量，如图：</p><p><img src=\"http://static.oschina.net/uploads/space/2014/1008/162256_ZmDR_254689.png\"></p><p>以上数值，单位为秒。</p><p>mysql允许设置闲置时间，默认是8小时，最大是1年。</p><p>大部分客户端都使用连接池以提高性能，如果用户访问量不大，连接池中的连接可能闲置时间超过数据库允许时间，数据库单方面断掉连接，而客户端却不知情。当下一个用户访问时，使用连接池中的连接，则会抛出上述异常。</p><p>解决方法可以是增大闲置时间。但这不是一个好方法。闲置时间是有上限的，在极端情况下，还是可能发生异常。此外，长时间保留闲置的连接，会降低数据库性能，消耗内存，最终耗尽数据库的连接数。所以不推荐增大闲置时间。</p><p>所以采用定时检测空闲连接</p><pre><code>\t\t&lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"300000\" /&gt;  <br>\t\t&lt;property name=\"minEvictableIdleTimeMillis\" value=\"600000\" /&gt; <br>\t\t&lt;property name=\"removeAbandoned\" value=\"true\"/&gt;</code></pre><p>但是要注意结合MySQL的wait_timeout来配置</p><p>不然要是wait_timeout设置为分钟，等你过五分钟才去检测，那还是会抛出异常。所以要调度好这个问题</p>',1,'Beloya','2018-07-27 10:39:57',NULL,NULL,0,99,0,1),
  (28,'ConcurrentHashMap实现原理','<p>为了填下项目的一堆坑，连续加了七天班<img width=\"35\" height=\"35\" changedsize=\"false\" src=\"https://tb2.bdstatic.com/tb/editor/images/client/image_emoticon12.png\">，现在才有时间更新博客<img width=\"35\" height=\"35\" changedsize=\"false\" src=\"https://tb2.bdstatic.com/tb/editor/images/client/image_emoticon6.png\"></p><p>前段时间曾经过面试一家公司的时候，被问到ConcurrentHashMap是怎么实现的，答曰：它分为 整个Hash表，segment（段），HashEntry（节点）三大结构。采用了\"分段锁\"策略，ConcurrentHashMap的主干是个Segment数组，每个segment就相当于一个HashTable。balabala。。。。</p><p>没想到面试官就疑惑的问我segment是什么，我说Segment是ConcurrentHashMap的主干，它是以数组达成了\"分段锁\"策略。Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其包含的若干个桶，在Segment里维护了一个HashEntry数组。balala....</p><p>没想到面试官居然觉得我错了<img src=\"http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/7a/shenshou_thumb.gif\" alt=\"[草泥马]\" data-w-e=\"1\">，我还想难道我记错了。灰溜溜的回来后查了一下资料。那就复习一下ConcurrentHashMap，好了废话不多说。开始吧</p><p>之前发的一篇文章讲述了在<a href=\"http://www.iyouju.club/archives/23_1\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255); color: rgb(70, 172, 200);\">高并发下的HashMap</a>会有线程安全的问题，尤其在扩容的时候会出现形成环状链表，造成死循环的问题，这是非常危险的事情。那么跟HashMap相似而且线程安全的就只有HashTable，它就比hashmap多了个线程安全和不允许key和value为null，虽然HashTable是线程安全的，但它实现线程安全的方式太简单粗暴了，使得为了线程安全花费代价却太大，get/put所有相关操作都是synchronized的，就相当于给整个哈希表加上了一把大锁,在其他线程访问或者操作的时候就会被阻塞，在竞争激烈的并发场景中性能就会非常差。然后1.5版本后ConcurrentHashMap就出现了</p><p><img src=\"https://images2015.cnblogs.com/blog/1024555/201705/1024555-20170514174100832-1891630860.png\" alt=\"\" width=\"937\" height=\"359\">&nbsp;&nbsp;</p><p>ConcurrentHashMap采用了非常精妙的\"分段锁\"策略，ConcurrentHashMap的主干是个Segment数组。</p><p>HashEntry是目前我们提到的最小的逻辑处理单元了。一个ConcurrentHashMap维护一个Segment数组，一个Segment维护一个HashEntry数组。\n\n</p><h3><span style=\"font-weight: bold;\">Java7 源码分析</span></h3><p><span style=\"font-size: large;\">我们先来看看ConcurrentHashMap主要成员</span></p><pre><code><p>static final int DEFAULT_INITIAL_CAPACITY = 16;<br><br>//扩容因子0.75<br>static final float DEFAULT_LOAD_FACTOR = 0.75f;</p><p>//默认并发标准16<br>static final int DEFAULT_CONCURRENCY_LEVEL = 16;</p>\n/**<br> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。<br> */<br>final Segment&lt;K,V&gt;[] segments;<br>transient Set&lt;K&gt; keySet;<br>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;\n<br></code></pre><p><span style=\"font-weight: bold; font-size: large;\">ConcurrentHashMap构造方法</span></p><pre><code>public ConcurrentHashMap(int initialCapacity,<br>                               float loadFactor, int concurrencyLevel) {<br>          if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)<br>              throw new IllegalArgumentException();<br>          //MAX_SEGMENTS 为1&lt;&lt;16=65536，也就是最大并发数为65536<br>          if (concurrencyLevel &gt; MAX_SEGMENTS)<br>              concurrencyLevel = MAX_SEGMENTS;<br>          //2的sshif次方等于ssize，例:ssize=16,sshift=4;ssize=32,sshif=5<br>         int sshift = 0;<br>         //ssize 为segments数组长度，根据concurrentLevel计算得出<br>         int ssize = 1;<br>         while (ssize &lt; concurrencyLevel) {<br>             ++sshift;<br>             ssize &lt;&lt;= 1;<br>         }<br>         this.segmentShift = 32 - sshift;<br>         this.segmentMask = ssize - 1;<br>         if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>             initialCapacity = MAXIMUM_CAPACITY;<br>         //计算cap的大小，即Segment中HashEntry的数组长度，cap也一定为2的n次方.<br>         int c = initialCapacity / ssize;<br>         if (c * ssize &lt; initialCapacity)<br>             ++c;<br>         int cap = MIN_SEGMENT_TABLE_CAPACITY;<br>         while (cap &lt; c)<br>             cap &lt;&lt;= 1;<br>         //创建segments数组并初始化第一个Segment，其余的Segment延迟初始化<br>         Segment&lt;K,V&gt; s0 =<br>             new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),<br>                              (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);<br>         Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];<br>         UNSAFE.putOrderedObject(ss, SBASE, s0); <br>         this.segments = ss;<br>     }</code></pre><p>初始化方法有三个参数，如果用户不指定则会使用默认值，initialCapacity为16，loadFactor为0.75（负载因子，扩容时需要参考），concurrentLevel为16。\n\n</p><p><span style=\"font-size: large;\">Segment 是 ConcurrentHashMap 的一个内部类</span>，主要的组成如下：\n\n</p><pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {<br>       private static final long serialVersionUID = 2249069246763182397L;<br>       <br>       // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶<br>       transient volatile HashEntry&lt;K,V&gt;[] table;<br>       transient int count;<br>       transient int modCount;<br>       transient int threshold;<br>       final float loadFactor;\n<p> Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) {<br>            this.loadFactor = lf;//负载因子</p><p>            this.threshold = threshold;//阈值</p><p>            this.table = tab;//主干数组即HashEntry数组</p><p>        }  </p>}</code></pre><p><span style=\"font-size: large;\">&nbsp;HashEntry 的组成</span>：\n\n</p><pre><code>static final class HashEntry&lt;K,V&gt; { <br>        final K key;                 // 声明 key 为 final 型<br>        final int hash;              // 声明 hash 值为 final 型 <br>        volatile V value;           // 声明 value 为 volatile 型<br>        final HashEntry&lt;K,V&gt; next;  // 声明 next 为 final 型 <br><br>        HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value)  { <br>            this.key = key; <br>            this.hash = hash; <br>            this.next = next; <br>            this.value = value; <br>        } <br> }</code></pre><p>ConcurrentHashMap和HashMap的<code>HashEntry&nbsp;</code>非常相似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p><p>Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。（就按默认的ConcurrentLeve为16来讲，理论上就允许16个线程并发执行），每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><h2><span style=\"font-weight: bold;\">用分段锁实现多个线程间的并发写操作</span></h2><h2><span style=\"font-weight: bold;\">Put方法的实现</span></h2><pre><code><p>  public V put(K key, V value) {<br>        Segment&lt;K,V&gt; s;<br>        //注意valus不能为空！！！<br>        if (value == null)<br>            throw new NullPointerException();<br>        //根据key计算hash值，key也不能为null，否则hash(key)报空指针<br>        int hash = hash(key);<br>        //根据hash值计算在segments数组中的位置<br>        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>        //查看当前数组中指定位置Segment是否为空<br>        //若为空，先创建初始化Segment再put值，不为空，直接put值。<br>        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck<br>             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment<br>            s = ensureSegment(j);<br>        return s.put(key, hash, value, false);<br>    }<br><br></p></code></pre><p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p><pre><code><p>final V put(K key, int hash, V value, boolean onlyIfAbsent) {</p><div><div>            HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value);</div><div>// 第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用&nbsp;scanAndLockForPut() 自旋获取锁。</div><div>// 如果重试的次数达到了&nbsp; MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。<br>            V oldValue;\n            try {\n                //获取Segment中的HashEntry[]\n                HashEntry&lt;K,V&gt;[] tab = table;\n                //算出在HashEntry[]中的位置\n                int index = (tab.length - 1) &amp; hash;\n                //找到HashEntry[]中的指定位置的第一个节点\n                HashEntry&lt;K,V&gt; first = entryAt(tab, index);\n                for (HashEntry&lt;K,V&gt; e = first;;) {\n                    //如果不为空，遍历这条链\n                    if (e != null) {\n                        K k;\n                        //情况① 之前已存过，则替换原值\n                        if ((k = e.key) == key ||\n                            (e.hash == hash &amp;&amp; key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else {\n                        //情况② 另一个线程的准备工作\n                        if (node != null)\n                            //链表头插入方式\n                            node.setNext(first);\n                        else //情况③ 该位置为空，则新建一个节点(注意这里采用链表头插入方式)\n                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);\n                        //键值对数量+1\n                        int c = count + 1;\n                        //如果键值对数量超过阈值\n                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)\n                            //扩容\n                            rehash(node);\n                        else //未超过阈值，直接放在指定位置\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        //插入成功返回null\n                        oldValue = null;\n                        break;\n                    }\n                }\n         \n            } finally {\n       \n                //解锁\n                unlock();\n            }\n            //修改成功，返回原值\n            return oldValue;\n        }</div></div><p>\n</p></code></pre><p>上面的 put 方法其实和 Java7 HashMap里大致是一样的，只是多了加锁/解锁两步，也正因为这样才保证了同一时刻只有一个线程拥有修改的权限。</p><p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。\n\n</p><p><span style=\"font-weight: bold;\">执行流程</span></p><div><div><blockquote><li>步骤① 执行 tryLock 方法获取锁，拿到锁返回null，没拿到锁执行 scanAndLockForPut 方法；</li><li>步骤② 和 HashMap 里的那一套思路是一样的，不理解可以看下之前的文章介绍(情况②下面介绍)；</li><li>步骤③   执行 unLock 方法解锁</li></blockquote>\n\n</div>假设现在有线程1进来，没有其他线程来过，它就可以成功拿到锁。\n根据计算，得出它要存的键值对应该放在HashEntry[] 的0号位置，0号位置为空，于是新建一个 HashEntry，并通过 setEntryAt() 方法，放在0号位置，然而还没等 线程1 释放锁，系统的时间片切到了线程2<br><img src=\"https://user-gold-cdn.xitu.io/2017/12/12/1604851619dba9c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n</div><p>线程2也恰好进同一个segments了，然后线程2就开始获取锁，当然这时候是不会成功的。执行scanAndLockForPut() 方法</p><pre><code>private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {<br>            //通过Segment和hash值寻找匹配的HashEntry<br>            HashEntry&lt;K,V&gt; first = entryForHash(this, hash);<br>            HashEntry&lt;K,V&gt; e = first;<br>            HashEntry&lt;K,V&gt; node = null;<br>            //重试次数<br>            int retries = -1; // negative while locating node<br>            //循环尝试获取锁<br>            while (!tryLock()) {<br>                HashEntry&lt;K,V&gt; f; // to recheck first below<br>                //步骤①<br>                if (retries &lt; 0) {<br>                    //情况① 没找到，之前表中不存在<br>                    if (e == null) {<br>                        if (node == null) // speculatively create node<br>                            //新建 HashEntry 备用,retries改成0<br>                            node = new HashEntry&lt;K,V&gt;(hash, key, value, null);<br>                        retries = 0;<br>                    }<br>                    //情况② 找到，刚好第一个节点就是，retries改成0<br>                    else if (key.equals(e.key))<br>                        retries = 0;<br>                    //情况③ 第一个节点不是，移到下一个，retries还是-1，继续找<br>                    else<br>                        e = e.next;<br>                }<br>                //步骤②<br>                //尝试了MAX_SCAN_RETRIES次还没拿到锁，放弃了<br>                else if (++retries &gt; MAX_SCAN_RETRIES) {<br>                    //挂机<br>                    lock();<br>                    break;<br>                }<br>                //步骤③<br>                //在MAX_SCAN_RETRIES次过程中，key对应的entry发生了变化，则从头开始<br>                else if ((retries &amp; 1) == 0 &amp;&amp;<br>                         (f = entryForHash(this, hash)) != first) {<br>                    e = first = f; // re-traverse if entry changed<br>                    retries = -1;<br>                }<br>            }<br>            return node;<br>        }</code></pre><div><div>线程2此时虽然没有权限操作，但是它也没闲着，在等待锁的时候，把自己要放的键值对在数组中哪个位置计算出来了，这样当 Thread2 一拿到锁就可以立马定位到具体位置操作，节省时间。</div></div><h2>get 方法</h2><pre><code>public V get(Object key) {<br>    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead<br>    HashEntry&lt;K,V&gt;[] tab;<br>    int h = hash(key);<br>    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;<br>        (tab = s.table) != null) {<br>        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != null; e = e.next) {<br>            K k;<br>            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                return e.value;<br>        }<br>    }<br>    return null;<br>}</code></pre><p>相比之下，get 方法没有加锁/解锁的操作\n\n</p><blockquote>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。<br>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。<br>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</blockquote><h2><span style=\"font-weight: bold;\">Java8 源码分析</span></h2><p>Java7中的ConcurrentHashMap 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。</p><blockquote>那就是查询遍历链表效率太低。\n\n</blockquote><p>因此 1.8 做了一些数据结构上的调整。\n\n</p><p><a href=\"https://ws3.sinaimg.cn/large/006tNc79gy1fthpv4odbsj30lp0drmxr.jpg\" rel=\"group\"><img src=\"https://ws3.sinaimg.cn/large/006tNc79gy1fthpv4odbsj30lp0drmxr.jpg\" alt=\"\"></a>\n\n</p><p>看起来和1.8的HashMap非常相似，&nbsp;<code>TREEIFY_THRESHOLD</code>&nbsp;用于判断是否需要将链表转换为红黑树的阈值。 HashEntry 修改为 Node。</p><p>当然除了数据结构上的调整，还抛弃了原有的 Segment 分段锁，而采用了&nbsp;<code>CAS + synchronized</code>&nbsp;来保证并发安全性。原来问题出在这里。1.8之后取消的Segment 分段锁，糗大了</p><p><img src=\"https://ws1.sinaimg.cn/large/9150e4e5ly1ftw7qn7zvgj20b40b4wer.jpg\"></p><p><span style=\"font-weight: bold; font-size: large;\">废话不多说，上源码！</span></p><p>ConcurrentHashMap的初始化\n\n</p><pre><code>public ConcurrentHashMap() {<br>}</code></pre><p>和Java7不一样，这里是个空方法，那么它具体的初始化操作呢？直接看下 put 方法</p><pre><code>public V put(K key, V value) {<br>    return putVal(key, value, false);<br>}<br><br>/** Implementation for put and putIfAbsent */<br>final V putVal(K key, V value, boolean onlyIfAbsent) {<br>    // key/value不能为空！！！<br>    if (key == null || value == null) throw new NullPointerException();<br>    //计算hash值<br>    int hash = spread(key.hashCode());<br>    int binCount = 0;<br>    for (Node&lt;K,V&gt;[] tab = table;;) {<br>        Node&lt;K,V&gt; f; int n, i, fh;<br>        //注释① 表为null则初始化<br>        if (tab == null || (n = tab.length) == 0)<br>            tab = initTable();<br>        //CAS方法判断指定位置是否为null，为空则通过创建新节点，通过CAS方法设置在指定位置<br>        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {<br>            if (casTabAt(tab, i, null,<br>                         new Node&lt;K,V&gt;(hash, key, value, null)))<br>                break;                   // no lock when adding to empty bin<br>        }<br>        //当前节点正在扩容<br>        else if ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        //指定位置不为空<br>        else {<br>            V oldVal = null;<br>            //注释② 加锁<br>            synchronized (f) {<br>                if (tabAt(tab, i) == f) {<br>                    //节点是链表的情况<br>                    if (fh &gt;= 0) {<br>                        binCount = 1;<br>                        //遍历整体链<br>                        for (Node&lt;K,V&gt; e = f;; ++binCount) {<br>                            K ek;<br>                            //如果已存在，替换原值<br>                            if (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != null &amp;&amp; key.equals(ek)))) {<br>                                oldVal = e.val;<br>                                if (!onlyIfAbsent)<br>                                    e.val = value;<br>                                break;<br>                            }<br>                            Node&lt;K,V&gt; pred = e;<br>                            //如果是新加节点，则以尾部插入实现添加<br>                            if ((e = e.next) == null) {<br>                                pred.next = new Node&lt;K,V&gt;(hash, key,<br>                                                          value, null);<br>                                break;<br>                            }<br>                        }<br>                    }<br>                    //节点是红黑树的情况<br>                    else if (f instanceof TreeBin) {<br>                        Node&lt;K,V&gt; p;<br>                        binCount = 2;<br>                        //遍历红黑树<br>                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != null) {<br>                            oldVal = p.val;<br>                            if (!onlyIfAbsent)<br>                                p.val = value;<br>                        }<br>                    }<br>                    else if (f instanceof ReservationNode)<br>                        throw new IllegalStateException(\"Recursive update\");<br>                }<br>            }<br>            if (binCount != 0) {<br>                //链表中节点个数超过8转成红黑树<br>                if (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                if (oldVal != null)<br>                    return oldVal;<br>                break;<br>            }<br>        }<br>    }<br>    //注释③ 添加节点<br>    addCount(1L, binCount);<br>    return null;<br>}</code></pre><p>代码过长，可能会引起不适，请在女朋友的陪同下观看。主要是因为引入了红黑树的判断和操作，以及线程安全的操作。同样key/value 为空会报空指针异常。</p><p><span style=\"font-weight: bold;\">注释①</span></p><p>调用 initTable 初始化数组</p><pre><code>private final Node&lt;K,V&gt;[] initTable() {<br>    Node&lt;K,V&gt;[] tab; int sc;<br>    while ((tab = table) == null || tab.length == 0) {<br>        // sizeCtl小于0，当前线程让出执行权<br>        if ((sc = sizeCtl) &lt; 0)<br>            Thread.yield(); // lost initialization race; just spin<br>        //CAS 操作将 sizeCtl 值改为-1<br>        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {<br>            try {<br>                if ((tab = table) == null || tab.length == 0) {<br>                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;<br>                    @SuppressWarnings(\"unchecked\")<br>                    //默认创建大小为16的数组<br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; 2);<br>                }<br>            } finally {<br>                //初始化完再改回来<br>                sizeCtl = sc;<br>            }<br>            break;<br>        }<br>    }<br>    return tab;<br>}</code></pre><div><blockquote>put方法并没有加锁，那么它是如何保证创建新表的时候并发安全呢？答案就是这里的 sizeCtl ，sizeCtl 默认值为0，当一个线程初始化数组时，会将 sizeCtl 改成 -1，由于被 volatile 修饰，对于其他线程来说这个变化是可见的，上面代码看到后续线程判断 sizeCtl 小于0 就会让出执行权。</blockquote><div style=\"\"><p style=\"\"><span style=\"font-weight: bold; color: rgb(0, 0, 0);\">注释②</span></p></div><span style=\"color: rgb(194, 79, 74);\">Java8 摒弃了Segment，而是对数组中单个位置加锁。当指定位置节点不为 null 时，情况与 Java8 HashMap 操作类似，新节点的添加还是尾部插入方式。\n\n</span></div><div><div><p><span style=\"font-weight: bold;\">注释③</span></p>\n<p>不管是链表的还是红黑树，确定之后总的节点数会加1，可能会引起扩容，Java8 ConcunrrentHashMap 支持并发扩容，之前扩容总是由一个线程将旧数组中的键值对转移到新的数组中，支持并发的话，转移所需要的时间就可以缩短了，当然相应的并发处理控制逻辑也就更复杂了，扩容转移通过 transfer 方法完成，由于代码过长可能会引起强烈不适这里我就不贴代码了，感兴趣的可以去看。</p><h2><span style=\"font-weight: bold;\">总结</span></h2></div><blockquote>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。<span style=\"color: rgb(194, 79, 74); background-color: rgb(238, 236, 224);\">最重要的是取消了Segment&nbsp;分段锁，采用了CAS+synchronized&nbsp;来保证并发安全性&nbsp;！！！！！</span></blockquote><img src=\"https://ws1.sinaimg.cn/large/9150e4e5ly1ftw7rhozd0j206o06oq2w.jpg\"></div><p><br></p>',1,'Beloya','2018-07-28 20:07:48','Beloya','2018-08-06 15:59:50',0,73,0,1),
  (29,'菜鸟学习设计模式系列-建造者模式','<h2><span style=\"font-weight: bold;\">工厂模式与建造者模式区别</span></h2><div>上篇文章中我们讨论了<a href=\"http://www.iyouju.club/archives/26_1\" target=\"_blank\" style=\"background-color: rgb(238, 236, 224); color: rgb(77, 128, 191);\">工厂模式</a>的实现以及思想，\n\n工厂模式一般都是创建一个产品&nbsp;或者一族产品而不用关心具体的实现，那么对于建造者模式呢？ 建造者模式也是创建一个产品，但是不仅要把这个产品创建出来，还要关系这个产品的组成细节，    组成过程。从代码上看（下面给出），建造者模式在建造产品时，这个产品有很多方法，建造者模式会根据这些相同方法但是不同执行顺序建造出不同组成细节的产品。</div><h2 id=\"2-建造者模式UML图\"><span style=\"font-weight: bold;\">2. 建造者模式UML图</span></h2><p><a href=\"http://ovcjgn2x0.bkt.clouddn.com/builder2.jpg\" rel=\"group\" title=\"builder模式\"><img src=\"http://ovcjgn2x0.bkt.clouddn.com/builder2.jpg\" alt=\"builder\" title=\"builder模式\"></a></p><p></p><p></p><p></p><p><a href=\"http://ovcjgn2x0.bkt.clouddn.com/builder2.jpg\" rel=\"group\" title=\"builder模式\">builder模式</a>角色说明：</p><blockquote><ul><li>抽象建造者（Builder）:抽象类， 规范产品的组建，一般是由子类实现具体的组件过程</li></ul><ul><li>具体建造者（ConcreteBuilder ）：具体的构建器</li></ul><ul><li>导演者（Director） : 统一组装过程(可省略)</li></ul><ul><li>产品（Product）:产品的抽象类</li></ul></blockquote><p>\"导演者\"是与客户端打交道的角色。Director将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体的ConcreteBuilder角色。ConcreteBuilder是做具体建造工作的，但是对客户端是透明的。</p><h2><span style=\"font-weight: bold;\">建造一封邮件</span></h2><div><span style=\"font-weight: bold; font-size: large;\">导演者\n\n</span></div><div><span style=\"font-weight: bold;\"><br></span></div><div><pre><code><p>public class EmailDirector {<br>private EmailBuilder emailBuilder;<br>public QQEmail construct(FileSystemResource file){<br><br>\temailBuilder.buildFromAddress();<br>\temailBuilder.buildToAddress();<br>\temailBuilder.buildSubject();<br>\temailBuilder.buildContent();<br>\temailBuilder.buildSupplement(file);<br>\treturn emailBuilder.returnQQEmail();<br>}<br>public EmailDirector(EmailBuilder emailBuilder) {<br>\tsuper();<br>\tthis.emailBuilder = emailBuilder;<br>}<br><br><br>}</p></code></pre><p><span style=\"font-weight: bold;\">抽象建造者\n\n</span></p></div><div><pre><code>public interface EmailBuilder {<br>\t/**<br>\t * 构建发件人信息<br>\t */<br>\tpublic void buildFromAddress();<br>\t/**<br>\t * 构建收件人信息<br>\t */<br>\tpublic void buildToAddress();<br>\t/**<br>\t * 构建邮件内容<br>\t */<br>\tpublic void buildContent();<br>\t/**<br>\t * 构建邮件附件<br>\t */<br>\tpublic void buildSupplement(FileSystemResource file);<br>\t/**<br>\t * 构建邮件主题<br>\t */<br>\tpublic void buildSubject();<br>\t/**<br>\t * 返回构建的产品<br>\t */<br>\tpublic QQEmail returnQQEmail();<br><br>}</code></pre><p><span style=\"font-weight: bold;\">具体建造者\n\n</span></p><pre><code>public class QQEmailBuilder implements EmailBuilder{<br>\tprivate QQEmail qqemail = new QQEmail();<br>\tpublic void buildFromAddress() {<br>\t\tqqemail.setFromemail(\"00000@qq.com\");<br>\t}<br><br>\tpublic void buildToAddress() {<br>\t\tqqemail.setTomail(\"000000@qq.com\");<br>\t}<br><br>\tpublic void buildContent() {<br>\t\tqqemail.setText(\"我写了一个建造者模式的例子，希望大佬给点意见\");<br>\t}<br><br>\tpublic void buildSupplement(FileSystemResource file) {<br>\t\tqqemail.setFile(file);<br>\t}<br><br>\tpublic void buildSubject() {<br>\t\tqqemail.setSubject(\"给大佬的一封建造者模式的Demo\");<br>\t}<br><br>\tpublic QQEmail returnQQEmail() {<br>\t\tSystem.out.println(qqemail.toString());<br>\t\treturn qqemail;<br>\t}<br>}</code></pre><p><span style=\"font-weight: bold;\">产品\n\n</span></p></div><div><pre><code>public class QQEmail {<br>\t/**<br>\t * QQEMAIL地址<br>\t */<br>\tprivate String host;<br>\t/**<br>\t * QQEMAIL端口<br>\t */<br>\tprivate int port;<br>\t/**<br>\t * 发件地址<br>\t */<br>\tprivate String tomail;<br>\t/**<br>\t * 收件地址<br>\t */<br>\tprivate String fromemail;<br>\t/**<br>\t * 邮件主题<br>\t */<br>\tprivate String subject;<br>\t/**<br>\t * 邮件内容<br>\t */<br>\tprivate String Text;<br>\t/**<br>\t * 发送时间<br>\t */<br>\tprivate Date senddate;<br>\t/**<br>\t * 邮件附件<br>\t */<br>\tprivate FileSystemResource file;<br><br>\tpublic String getHost() {<br>\t\treturn host;<br>\t}<br>\tpublic void setHost(String host) {<br>\t\tthis.host = host;<br>\t}<br>\tpublic int getPort() {<br>\t\treturn port;<br>\t}<br>\tpublic void setPort(int port) {<br>\t\tthis.port = port;<br>\t}<br>\tpublic String getTomail() {<br>\t\treturn tomail;<br>\t}<br>\tpublic void setTomail(String tomail) {<br>\t\tthis.tomail = tomail;<br>\t}<br><br>\tpublic String getFromemail() {<br>\t\treturn fromemail;<br>\t}<br>\tpublic void setFromemail(String fromemail) {<br>\t\tthis.fromemail = fromemail;<br>\t}<br>\tpublic String getSubject() {<br>\t\treturn subject;<br>\t}<br>\tpublic void setSubject(String subject) {<br>\t\tthis.subject = subject;<br>\t}<br>\tpublic String getText() {<br>\t\treturn Text;<br>\t}<br>\tpublic void setText(String text) {<br>\t\tText = text;<br>\t}<br>\tpublic Date getSenddate() {<br>\t\treturn senddate;<br>\t}<br>\tpublic void setSenddate(Date senddate) {<br>\t\tthis.senddate = senddate;<br>\t}<br><br>\tpublic FileSystemResource getFile() {<br>\t\treturn file;<br>\t}<br>\tpublic void setFile(FileSystemResource file) {<br>\t\tthis.file = file;<br>\t}<br>\t@Override<br>\tpublic String toString() {<br>\t\treturn \"QQEmail [tomail=\" + tomail + \", fromemail=\" + fromemail + \", subject=\" + subject + \", Text=\" + Text<br>\t\t\t\t+ \", senddate=\" + senddate + \", file=\" + file + \"]\";<br>\t}<br>\t<br>}</code></pre><p><span style=\"font-weight: bold;\">测试类</span></p></div><div><pre><code>File file=new File(\"D:\\\\app\\\\HelloWorld.txt\");<br>\t\tFileSystemResource filere=new FileSystemResource(file);<br>\t\tEmailDirector emd=new EmailDirector(new QQEmailBuilder());<br>\t\temd.construct(filere);</code></pre><p><span style=\"font-weight: bold;\">输出结果</span></p><blockquote><p>QQEmail [tomail=000000@qq.com, fromemail=00000@qq.com, subject=给大佬的一封建造者模式的Demo, Text=我写了一个建造者模式的例子，希望大佬给点意见, senddate=null, file=file [D:\\app\\HelloWorld.txt]]</p></blockquote></div><h1><span style=\"font-size: medium; font-weight: bold;\">&nbsp;</span><span style=\"font-weight: bold; font-size: x-large; font-family: 微软雅黑;\">总结</span></h1><blockquote><span style=\"font-size: medium;\">建造者模式与抽象工厂模式有点相似，但建造者模式侧重完成完整的产品的组成，而</span>抽象工厂侧重完成一系列相关的产品。在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型并指导Director类如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回。</blockquote><p>在实际的应用过程中，建造者模式也有不同的变种，比如说省略抽象建造者角色或者省略导演者角色等等，在某些情况下，建造者模式可以通过省略某些角色来达到过度到模板方法模式。</p><p>关于建造者模式的其他变种这里就不讨论了，留一个想象空间！<img pic_type=\"1\" width=\"30\" height=\"30\" src=\"https://tb2.bdstatic.com/tb/editor/images/face/i_f25.png?t=20140803\"></p>',1,'Beloya','2018-08-06 21:40:33','Beloya','2018-08-07 12:26:07',0,170,0,1),
  (30,'压力测试','<p>11</p>',1,'Beloya','2018-08-07 16:31:21',NULL,NULL,-1,2,0,2),
  (31,'压力测试','<p>1111</p>',1,'Beloya','2018-08-07 16:32:04',NULL,NULL,-1,0,0,2),
  (32,'Shrio+Redis集群+Nginx负载均衡的血与泪','<p>前几天感觉博客加载有点慢，看了一下Chrome的性能调试发现静态资源加载有点慢,然后就想到了用nginx进行反向代理。然后觉得反正使用nginx了，那就直接上负载均衡搞个蓝绿部署什么的。刚开始配置意料之外的顺利，但是到了session共享上仿佛掉进了深坑，用空余时间折腾了好久，从Shrio的源码查完，再看到Shrio-Redis的源码都无果，都是血与泪折腾了好久，搞的也没时间写博客。好不容易解决了，我得写个博客压压惊。记录一下整个过程踩得所有的坑</p><p><img src=\"https://imgsa.baidu.com/forum/w%3D580/sign=91c0fa71805494ee87220f111df4e0e1/6eecc51b9d16fdfacd4fbd20b88f8c5495ee7be4.jpg\"></p><h2>先上个构想中的负载均衡的图</h2><p><br></p><p><img title=\"Shiro安全框架基于Redis的分布式集群方案_\" 图片1=\"\" src=\"https://img.mukewang.com/5a7bfbae00016b5808640531.png\" alt=\"图片描述\"><br><br></p><h2>Nginx的搭建</h2><p>先安装Nginx</p><p>官网中下载所需版本：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\">http://nginx.org/en/download.html</a></p><h3>开启Nginx</h3><p>开启Nginx有两种方法，一种是直接点击开启，一种是命名行开启。</p><p>a.点击开启：</p><p>&nbsp; &nbsp;<img src=\"https://images2015.cnblogs.com/blog/656746/201605/656746-20160510160221296-1536339450.png\" alt=\"\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p><p>b.命名行开启：</p><p>&nbsp;<img src=\"https://images2015.cnblogs.com/blog/656746/201605/656746-20160510160230671-1519899707.png\" alt=\"\"></p><p>开启成功后，在资源管理中可以看到：</p><p>&nbsp;<img src=\"https://images2015.cnblogs.com/blog/656746/201605/656746-20160510160237921-357189165.png\" alt=\"\"></p><p>nginx.conf配置</p><pre><code>此处只贴出http块的配置\ndefault_type  application/octet-stream;<br><br>    #log_format  main  ''$remote_addr - $remote_user [$time_local] \"$request\" ''<br>    #                  ''$status $body_bytes_sent \"$http_referer\" ''<br>    #                  ''\"$http_user_agent\" \"$http_x_forwarded_for\"'';<br><br>    #access_log  logs/access.log  main;<br><br>   <br>    #tcp_nopush     on;<br> client_max_body_size 30m;<br>    #keepalive_timeout  0;<br> #设置客户端连接保持活动的超时时间<br>            keepalive_timeout   65;<br>            server_tokens   off;<br>   #开启高效模式文件传输模式，将tcp_nopush和tcp_nodelay两个指另设置为on，用于防止网络阻塞。<br>            sendfile    on;<br>            tcp_nopush  on;<br>            tcp_nodelay on;<br>    #开启gzip<br>            gzip    on;<br>            #允许压缩的最小字节数<br>            gzip_min_length 1k;<br>            #4个单位为16k的内存作为压缩结果流缓存<br>            gzip_buffers 4 16k;<br>            #设置识别HTTP协议版本，默认是1.1<br>            gzip_http_version 1.1;<br>            #gzip压缩比，可在1~9中设置，1压缩比最小，速度最快，9压缩比最大，速度最慢，消耗CPU<br>            gzip_comp_level 2;<br>            #压缩的类型<br>            gzip_types text/plain application/x-javascript text/css application/xml;<br>            #让前端的缓存服务器混村经过的gzip压缩的页面<br>            gzip_vary   on;<br>\t<br>\t  #客户端请求主体读取缓存<br>            client_body_buffer_size 512k;<br>            proxy_connect_timeout   5;<br>            proxy_send_timeout      60;<br>            proxy_read_timeout      5;<br>            proxy_buffer_size       16k;<br>            proxy_buffers           4 64k;<br>            proxy_busy_buffers_size 128k;<br>            proxy_temp_file_write_size 128k;<br>\t<br>\t<br>\t   upstream MyBlog_Server {<br>#默认 轮询<br>#fair:按照后端服务器的响应时间来分配<br>#url_hash:按照url规则进行分配,使得固定的请求分配到固定的服务器上        <br>          server 127.0.0.1:8080 weight=2;<br>          server 119.x.x.x:80 weight=2;<br>      }<br><br>\t<br>    server {<br>        listen       80;<br>        server_name  localhost;<br>        charset    utf-8;<br>        #charset koi8-r;<br><br>        #access_log  logs/host.access.log  main;<br><br>        location / {<br>            proxy_next_upstream http_502 http_504 error timeout invalid_header;<br>\t\t\t  proxy_pass http://MyBlog_Server;<br>             #设定代理服务器组<br>\t\t\t  # 真实的客户端IP<br>                    proxy_set_header   X-Real-IP        $remote_addr; <br>                    # 请求头中Host信息<br>                    proxy_set_header   Host             $host; <br>                    # 代理路由信息，此处取IP有安全隐患<br>                    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;<br>                    # 真实的用户访问协议<br>                    proxy_set_header   X-Forwarded-Proto $scheme;<br>        }<br>   location ~ .*\\.(js|css|ico|png|jpg|eot|svg|ttf|woff) {<br>             #所有静态文件直接读取硬盘内容:读取的静态资源存放位置<br>\t\t\t  proxy_cache_valid 200 304 302 5d;<br>              proxy_cache_valid any 5d;<br>           root   C:\\apache-tomcat-8.5.32\\webapps\\ROOT ;<br>  #资源是否进行缓存与缓存时间<br>             expires 30d; #缓存30天<br>         }</code></pre><p>配置好后就可以直接启动了，然后输入地址<a href=\"http://www.iyouju.club/\" target=\"_blank\">http://www.iyouju.club/</a>就可以访问了。意料之外的顺利就跑起来了</p><p>当然不要以为这就完事OK了，在两个Tomcat下如果两个Tomcat切换是不是会出现session不一致的问题，然后导致session丢失。</p><p>接下来就需要共享session了，由于框架中有shiro自带了session那么就有两种方案</p><h2>Shrio实现session共享方案</h2><blockquote>1、传统的做法是通过配置 web 容器，通过容器间 session 的复制达到共享的目的<br>2、重写shiro的SessionDao将session存入redis(或其他)来实现session共享</blockquote><p>由于我的博客本身就是用Redis进行缓存文章，那么就采用存入Redis进行管理，本着折腾精神既然都搞负载均衡了，不如就直接上Redis哨兵—实现Redis高可用，结果变得不可用了</p><p><img src=\"https://imgsa.baidu.com/forum/w%3D580/sign=2808333770d98d1076d40c39113db807/f8aec0ef76094b36aa7abe26afcc7cd98c109d10.jpg\" size=\"575153\" width=\"285\" height=\"282\"></p><p>后来发现很多博客有误导的复制粘贴，那么我只能去看下文档才搞定</p><h2>部署的拓扑结构如图示例(当然我只有一个sentinel一个master和一个slave)：</h2><p><img src=\"https://img-blog.csdn.net/20170525125117120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWVuX3dlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"></p><p>贴一下我正常跑起来的配置吧。</p><p>Master配置</p><pre><code>#bind 127.0.0.1\n#注释掉或指定地址\nport 6380\n<p>masterauth 123456</p><p>#指定Redis的master密码</p><p>requirepass 123456</p><p>#Redis的密码</p><p>daemonize yes</p><p>#redis将以守护进程的方式运行，这样可以在redis服务启动的窗口中再可以进行其它操作</p></code></pre><p><strong>slave.conf配置</strong></p><pre><code>##配置了master的认证密码，作为salve要同步master的数据，不配置就连不上master<br>masterauth 123456<br>##客户端连接的时候需要6380。<br>requirepass 123456\n<p>#bind 127.0.0.1</p><p>dir \"C:\\\\Redis\"</p><p>port 6380\nslaveof 192.168.0.120 6380\n</p><p>#master地址</p></code></pre><p><strong>sentinel.conf配置</strong></p><pre><code>port 26379<br><p>dir \"C:\\\\Redis\"</p>sentinel monitor mymaster 111.231.215.38 6380 1<br>#mymaster 是mater的名字<br>sentinel auth-pass mymaster nidejiaobu.7\n<p>protected-mode no</p><p>#是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码   和bind，可以开启。否则最好关闭，设置为no。</p></code></pre><p>然后依次启动服务master-&gt;slave-&gt;sentinel</p><p>然后就可以愉快的跑起来了。</p><p>接下来就是连接集群的问题。一开始我是想通过shrio-redis进行管理的，但是不知道为什么用这个后SecurityUtils无法获取到session总是为空，而且doReadSession太频繁打开一个页面从Redis读取了将就二十次session。而且doUpdate方法也是很频繁，来更新Redis上数据，过来发现更新的字段只有LastAccessTime（最后一次访问时间），由于会话失效是由Redis数据过期实现的，这个字段意义不大</p><blockquote>这个是shiro &nbsp;设计上的问题， 主要是因为shiro 框架获取 session里面的属性时，每次都去拿取session，一次请求中会有很多次 获取 session 里面的属性。</blockquote><p>那么就只能自己实现了，重写<strong>AbstractSessionDAO。通过</strong>redisTemplate来操作Redis。然后大坑就在这里。本来是美滋滋的看起来好像是解决了。但是发现在登录的时候，Shiro的doGetAuthenticationInfo的验证方法中getSubject获取到的session为空抛出异常。当时我就纳闷了。一查看日志发现前面执行了很多次doReadSession读取session，但是到了getSubject的时候doReadSession获取到的session就为空了???</p><p><img src=\"https://imgsa.baidu.com/forum/w%3D580/sign=c5cd07d0d80735fa91f04eb1ae530f9f/f0d8bdfd5266d01667f13be39b2bd40734fa3510.jpg\" size=\"15924\" width=\"240\" height=\"240\"></p><p>完全不理解这是什么情况。看起来是getSubject的时候出问题了，那么就只能看shiro源码一层层定位。结果看完没毛病啊，然后我以为配置配错了导致getSubject读取的Key不对，又去看了一遍代码的所有执行流程。好像也没毛病啊。搞的以为什么细节漏了就重来一遍配置，折腾了一天。</p><p><img src=\"https://imgsa.baidu.com/forum/w%3D580/sign=840e2470c5177f3e1034fc0540cd3bb9/88379c0a304e251fc00c523eab86c9177e3e5304.jpg\" size=\"18601\" width=\"440\" height=\"440\"></p><p>重新配置后还是这个问题。然后看着redisTemplate发呆，然后觉得会不会是这玩意的bug啊。然后就切换成jedis来操作。结果就成功了！！</p><p><img src=\"https://imgsa.baidu.com/forum/w%3D580/sign=8878aa2236f33a879e6d0012f65c1018/ca3850b5c9ea15ce6b92c91bba003af33a87b2a3.jpg\" size=\"3076\" width=\"119\" height=\"99\"></p><p>也是醉了，没想到被redisTemplate坑了一把。如果有原因知道的大佬求指教。已经肝不动源码了</p><p><img src=\"https://imgsa.baidu.com/forum/w%3D580/sign=e54b14064ea7d933bfa8e47b9d4ad194/1d043efae6cd7b8974a91491032442a7d8330eda.jpg\" size=\"39732\" changedsize=\"true\" width=\"560\" height=\"560\"></p><p>那么共享session就解决了，接下来就是解决频繁读取和更新session的问题</p><p>那么就只能自己实现了重写EnterpriseCacheSessionDAO先读取本地缓存，如果没再去Redis读取。并且过滤静态文件不读取session。<a href=\"https://blog.csdn.net/zsg88/article/details/77018543\" target=\"_blank\">springmvc中判断当前访问是否静态资源</a></p><p>再通过在SimpleSession上套一层，增加一个标识位，如果Session除lastAccessTime意外其它字段修改，就标识一下，只有标识为修改的才可以通过doUpdate访问Redis，否则直接返回</p><p>直接上代码</p><h2>配置文件更改</h2><p>Spring-Shrio.xml</p><pre><code>&lt;!-- Session ID 生成器 --&gt;<br>    &lt;bean id=\"sessionIdGenerator\"&gt;&lt;/bean&gt;<br>&lt;!-- redis操作 --&gt;<br>  &lt;bean id=\"redisSessionService\"&gt;<br>        &lt;property name=\"expire\" value=\"10800\"/&gt;<br>        &lt;property name=\"sessionIdGenerator\" ref=\"sessionIdGenerator\"&gt;&lt;/property&gt;<br>    &lt;/bean&gt; <br>    &lt;!-- Session管理器 --&gt;<br>&lt;bean id=\"sessionManager\"&gt; <br>        &lt;!-- 会话超时时间，单位：毫秒  20m=1200000ms, 30m=1800000ms, 60m=3600000ms--&gt;<br>        &lt;property name=\"globalSessionTimeout\" value=\"43200000\"/&gt;<br>        &lt;!-- 会话验证器调度时间 --&gt;<br>        &lt;property name=\"sessionValidationInterval\" value=\"1800000\"/&gt;<br>        &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;<br>         &lt;property name=\"sessionDAO\" ref=\"redisSessionService\"&gt;&lt;/property&gt;<br>           &lt;property name=\"deleteInvalidSessions\" value=\"true\"/&gt;<br>        &lt;property name=\"sessionIdUrlRewritingEnabled\" value=\"false\" /&gt;<br>        &lt;property name=\"sessionIdCookie\" ref=\"sharesession\"/&gt;<br>        &lt;property name=\"sessionIdCookieEnabled\" value=\"true\"/&gt;<br>        &lt;property name=\"sessionListeners\"&gt;<br>            &lt;list&gt;<br>                &lt;bean/&gt;<br>            &lt;/list&gt;<br>        &lt;/property&gt;<br>          &lt;!-- 定时检查失效的session --&gt;<br>        &lt;property name=\"sessionValidationSchedulerEnabled\" value=\"true\"/&gt;<br>       <br>       <br>&lt;/bean&gt;<br>&lt;!-- 自定义Session工厂方法 返回会标识是否修改主要字段的自定义Session--&gt;<br>    &lt;bean id=\"sessionFactory\"/&gt;<br>    <br>     &lt;!-- sessionIdCookie的实现,用于重写覆盖容器默认的JSESSIONID --&gt;<br>    &lt;bean id=\"sharesession\"&gt;<br>        &lt;!-- cookie的name,对应的默认是 JSESSIONID --&gt;<br>        &lt;constructor-arg name=\"name\" value=\"shrio_session\"/&gt;  <br>        &lt;!-- jsessionId的path为 / 用于多个系统共享jsessionId --&gt;<br>       <br>        &lt;property name=\"path\" value=\"\"/&gt;<br> <br>        &lt;property name=\"httpOnly\" value=\"true\"/&gt;<br>    &lt;/bean&gt; <br>  &lt;bean id=\"rememberMeCookie\"&gt;<br>         &lt;constructor-arg value=\"COOKIE_NAME\" /&gt;<br>        &lt;property name=\"httpOnly\" value=\"true\" /&gt;<br>        &lt;property name=\"maxAge\" value=\"604800\" /&gt;<br>    &lt;/bean&gt;<br>    &lt;bean id=\"rememberMeManager\"&gt;<br>         &lt;property name=\"cipherKey\" value=\"#{T(org.apache.shiro.codec.Base64).decode(''4AvVhmFLUs0KTA3Kprsdag=='')}\" /&gt;<br>         &lt;property name=\"cookie\" ref=\"rememberMeCookie\" /&gt;<br>     &lt;/bean&gt;<br>      &lt;bean&gt;<br>         &lt;property name=\"securityManager\" ref=\"securityManager\" /&gt;<br>     &lt;/bean&gt;<br>      <br>      &lt;!-- 配置进行授权和认证的 Realm --&gt;  <br>        &lt;bean id=\"myRealm\"&gt;   <br>             &lt;property name=\"userService\" ref=\"userService\" /&gt;        <br>         &lt;/bean&gt;  <br>         <br>         &lt;bean id=\"userService\" /&gt;  <br>   <br>   &lt;bean id=\"securityManager\"&gt;  <br>            &lt;!--property name=\"cacheManager\" ref=\"shiroEhcacheManager\"/--&gt;   <br>             &lt;property name=\"realm\" ref=\"myRealm\"/&gt;   <br>          <br>                &lt;!--将session托管给redis进行管理，便于搭建集群系统--&gt;<br>              &lt;property name=\"sessionManager\" ref=\"sessionManager\"/&gt;<br>              &lt;property name=\"rememberMeManager\" ref=\"rememberMeManager\"/&gt; <br>       &lt;/bean&gt;  <br>      &lt;bean id=\"lifecycleBeanPostProcessor\"/&gt;</code></pre><p>Spring.xml</p><pre><code><p>&lt;bean id=\"propertyConfigurer\"<br>\t&gt;<br>\t\t&lt;property name=\"locations\"&gt;<br>\t\t\t&lt;list&gt;<br>\t\t\t\t&lt;value&gt;classpath:jdbc.properties&lt;/value&gt;<br>\t\t\t\t&lt;value&gt;classpath:redis.properties&lt;/value&gt;<br>\t\t\t&lt;/list&gt;<br>\t\t&lt;/property&gt; <br>\t&lt;/bean&gt;<br>\t  &lt;!-- 连接池 --&gt;<br>\t&lt;bean id=\"dataSource\"<br>\t\tinit-method=\"init\" destroy-method=\"close\"&gt;<br>\t\t&lt;property name=\"driverClassName\" value=\"${driver}\" /&gt;<br>\t\t&lt;property name=\"url\" value=\"${url}\" /&gt;<br>\t\t&lt;property name=\"username\" value=\"${username}\" /&gt;<br>\t\t&lt;property name=\"password\" value=\"${password}\" /&gt;<br>\t\t&lt;!-- 初始化连接大小 --&gt;<br>\t\t&lt;property name=\"initialSize\" value=\"${initialSize}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 连接池最大数量 --&gt;<br>\t\t&lt;property name=\"maxActive\" value=\"${maxActive}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 连接池最大空闲 --&gt;<br>\t\t&lt;property name=\"maxIdle\" value=\"${maxIdle}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 连接池最小空闲 --&gt;<br>\t\t&lt;property name=\"minIdle\" value=\"${minIdle}\"&gt;&lt;/property&gt;<br>\t\t&lt;!-- 获取连接最大等待时间 --&gt;<br>\t\t&lt;property name=\"maxWait\" value=\"${maxWait}\"&gt;&lt;/property&gt;<br>\t\t&lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" /&gt;  <br>\t\t&lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\" /&gt; <br>\t<br>\t\t&lt;!-- 验证数据库连接的有效性 --&gt;<br>\t\t     &lt;property name=\"validationQuery\" value=\"SELECT 1\" /&gt;<br>\t\t     &lt;!-- 指明连接是否被空闲连接回收器(如果有)进行检验.如果检测失败,则连接将被从池中去除.   --&gt;<br>\t\t      &lt;property name=\"testWhileIdle\" value=\"true\" /&gt;<br>\t\t       &lt;property name=\"testOnBorrow\" value=\"false\" /&gt;<br>\t\t       &lt;!-- returnObject对返回的connection进行validateObject校验 --&gt;<br>\t\t       &lt;property name=\"testOnReturn\" value=\"false\" /&gt;<br>\t\t       &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小   缓存游标--&gt;<br>\t\t        &lt;property name=\"poolPreparedStatements\" value=\"true\" /&gt;<br>\t\t        &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\"<br>                  value=\"20\" /&gt;<br>\t\t         &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;<br>\t\t            &lt;property name=\"filters\" value=\"stat\" /&gt;<br>\t&lt;/bean&gt;<br>\t&lt;!-- bean id=\"sqlSessionFactory\"&gt; <br>\t\t&lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"mapperLocations\" <br>\t\tvalue=\"classpath:com/MyBlog/Mapping/*.xml\"&gt;&lt;/property&gt; &lt;/bean --&gt;<br>\t&lt;bean id=\"sqlSessionFactory\"&gt;<br>\t\t&lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;<br>\t\t&lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\" /&gt;<br>\t&lt;/bean&gt;<br>\t<br>\t&lt;bean&gt;<br>\t\t&lt;property name=\"basePackage\" value=\"com.MyBlog.Dao\" /&gt;<br>\t\t&lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;<br><br>\t&lt;/bean&gt;<br>\t&lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt;<br>\t\t&lt;!-- 事务传播属性 --&gt;<br>\t\t&lt;tx:attributes&gt;<br>\t\t\t&lt;!-- 所有已get、query、select开头的方法都是只读 --&gt;<br>\t\t\t&lt;tx:method name=\"get*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;tx:method name=\"query*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;tx:method name=\"select*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;tx:method name=\"Find*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;tx:method name=\"read*\" read-only=\"true\" /&gt;<br>\t\t\t&lt;!-- 其它的所有方法支持事务设置的属性（异常回滚） --&gt;<br>\t\t\t&lt;tx:method name=\"*\"  /&gt;<br>\t\t&lt;/tx:attributes&gt;<br>\t&lt;/tx:advice&gt;<br>\t&lt;!-- 事务拦截切面 --&gt;<br> &lt;aop:config&gt;<br>        &lt;aop:pointcut id=\"ServiceTxOperation\" expression=\"execution(* com.MyBlog.Service.*.*(..))\"/&gt;<br>        &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"ServiceTxOperation\"/&gt;<br>    &lt;/aop:config&gt;<br>    <br>\t&lt;bean id=\"txManager\"<br>\t&gt;<br>\t\t&lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;<br>\t&lt;/bean&gt;<br>\t\t&lt;!-- 事务开启 --&gt;<br>    &lt;tx:annotation-driven proxy-target- transaction-manager=\"transactionManager\"/&gt;<br>    <br>\t&lt;!-- redis数据源 --&gt;<br>\t&lt;bean id=\"poolConfig\"&gt;<br>\t\t&lt;property name=\"maxIdle\" value=\"${redis.maxIdle}\" /&gt;<br>\t\t&lt;property name=\"maxTotal\" value=\"${redis.maxActive}\" /&gt;<br>\t\t&lt;property name=\"maxWaitMillis\" value=\"${redis.maxWait}\" /&gt;<br>\t\t        &lt;property name=\"blockWhenExhausted\" value=\"${redis.blockWhenExhausted}\" /&gt; <br>\t\t&lt;property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" /&gt;<br>\t&lt;/bean&gt;<br>\t    &lt;bean id=\"jedisConnectionFactory\"<br>          &gt;<br>        &lt;constructor-arg name=\"sentinelConfig\" ref=\"redisSentinelConfiguration\"&gt;&lt;/constructor-arg&gt;<br>        &lt;constructor-arg name=\"poolConfig\" ref=\"poolConfig\"&gt;&lt;/constructor-arg&gt;<br>        &lt;property name=\"password\" value=\"${redis.pass}\"&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br>    <br>   &lt;!-- bean id=\"jedisPool\"&gt;<br>\t&lt;constructor-arg name=\"masterName\" value=\"mymaster\" /&gt;<br>\t&lt;constructor-arg name=\"sentinels\"&gt;<br>\t\t&lt;set&gt;<br>\t\t\t&lt;value&gt;${redis.host3.cloudq}:${redis.port3.cloudq}&lt;/value&gt;<br>\t\t<br>\t\t&lt;/set&gt;<br>\t&lt;/constructor-arg&gt;<br>\t&lt;constructor-arg ref=\"poolConfig\" /&gt;<br>\t&lt;constructor-arg index=\"3\" value=\"${redis.pass}\" /&gt;<br>&lt;/bean--&gt;<br>\t\t &lt;!--配置redisSentinelConfiguration 哨兵模式--&gt;<br>    &lt;bean id=\"redisSentinelConfiguration\"<br>         &gt;<br>        &lt;property name=\"master\"&gt;<br>            &lt;bean&gt;<br>                &lt;property name=\"name\" value=\"mymaster\"&gt;<br>                &lt;/property&gt;<br>            &lt;/bean&gt;<br>        &lt;/property&gt;<br>        &lt;property name=\"sentinels\"&gt;<br>            &lt;set&gt;<br>                &lt;bean&gt;<br>                    &lt;constructor-arg name=\"host\" value=\"${redis.host3.cloudq}\"/&gt;<br>                    &lt;constructor-arg name=\"port\" value=\"${redis.port3.cloudq}\"/&gt;<br>                &lt;/bean&gt;<br>            &lt;/set&gt;<br>        &lt;/property&gt;<br>    &lt;/bean&gt;<br><br>&lt;!--bean id=\"redisHttpSessionConfiguration\"<br>     &gt;<br>    &lt;property name=\"maxInactiveIntervalInSeconds\" value=\"600\"/&gt;<br>&lt;/bean--&gt;<br>&lt;!-- 静态资源检查 --&gt;<br>&lt;bean id=\"resourceUrlProvider\"/&gt;<br>\t\t&lt;bean id=\"genericUtils\" /&gt;<br>\t&lt;!-- spring-&gt;\t&lt;!--bean id=\"redisTemplate\"&gt;<br>\t\t&lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt;<br>\t\t  &lt;property name=\"keySerializer\"&gt;<br>            &lt;bean /&gt;<br>        &lt;/property&gt;<br>        &lt;property name=\"valueSerializer\"&gt;<br>            &lt;bean /&gt;<br>        &lt;/property&gt;<br>        &lt;property name=\"hashKeySerializer\"&gt;<br>            &lt;bean /&gt;<br>        &lt;/property&gt;<br>        &lt;property name=\"hashValueSerializer\"&gt;<br>            &lt;bean /&gt;<br>        &lt;/property&gt;<br>        <br>        &lt;property name=\"enableTransactionSupport\"  value=\"true\"&gt;&lt;/property&gt;  <br>\t&lt;/bean--&gt;<br><br>\t&lt;bean id=\"redisCacheTransfer\"&gt;<br>\t\t&lt;property name=\"jedisConnectionFactory\" ref=\"jedisConnectionFactory\" /&gt;<br>\t&lt;/bean&gt;<br>\t&lt;bean id=\"RedisDb\"&gt;<br>\t\t&lt;property name=\"jedisConnectionFactory\" ref=\"jedisConnectionFactory\" /&gt;<br>\t&lt;/bean&gt;<br>\t&lt;!-- 配置RedisCacheConfig --&gt;<br>\t &lt;!-- bean id=\"redisrCacheManager\"&gt;  <br>        &lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt;  <br>    &lt;/bean--&gt;</p></code></pre><p>Spring-Mvc.xml</p><pre><code>&lt;mvc:annotation-driven /&gt;<br>\t&lt;mvc:interceptors&gt;<br>\t&lt;mvc:interceptor&gt;<br>            &lt;mvc:mapping path=\"/**\"/&gt;<br>            &lt;bean/&gt;<br>        &lt;/mvc:interceptor&gt;<br>\t&lt;/mvc:interceptors&gt;<br>\t&lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;<br>\t &lt;bean id=\"mappingJacksonHttpMessageConverter\"<br> &gt;<br>  &lt;property name=\"supportedMediaTypes\"&gt;<br>   &lt;list&gt;<br>    &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;<br>   &lt;/list&gt;<br>  &lt;/property&gt;<br> &lt;/bean&gt; <br> \t&lt;!-- 配置静态资源，直接映射到对应的文件夹，不被DispatcherServlet处理，3.04新增功能，需要重新设置spring-mvc-3.0.xsd --&gt;<br>\t&lt;mvc:resources mapping=\"/img/**\" location=\"/images/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/fonts/**\" location=\"/user2/images/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/Html\" location=\"/Html\" /&gt;<br>\t&lt;mvc:resources mapping=\"/plugins/**\" location=\"/plugins/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\" /&gt;<br>\t&lt;mvc:resources mapping=\"/css/**\" location=\"/css/\" /&gt;<br>\t  &lt;mvc:default-servlet-handler/&gt; <br>\t&lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;<br>&lt;bean&gt;<br>  &lt;property name=\"messageConverters\"&gt;<br>   &lt;list &gt;<br>    &lt;ref bean=\"mappingJacksonHttpMessageConverter\" /&gt;<br>   &lt;/list&gt;<br>  &lt;/property&gt;<br> &lt;/bean&gt;<br> <br>\t&lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;<br>\t&lt;bean&gt;<br>\t\t&lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;<br>\t\t&lt;property name=\"prefix\" value=\"/\" /&gt;<br>\t\t&lt;property name=\"suffix\" value=\".jsp\" /&gt;<br>\t&lt;/bean&gt;<br><br><br>\t&lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;<br>\t&lt;bean id=\"multipartResolver\"  <br>       &gt;  <br>        &lt;!-- 默认编码 --&gt;<br>        &lt;property name=\"defaultEncoding\" value=\"utf-8\" /&gt;  <br>        &lt;!-- 文件大小最大值 --&gt;<br>        &lt;property name=\"maxUploadSize\" value=\"10485760000\" /&gt;  <br>        &lt;!-- 内存中的最大值 --&gt;<br>        &lt;property name=\"maxInMemorySize\" value=\"40960\" /&gt;  <br>    &lt;/bean&gt; \n&lt;!--静态资源拦截器--&gt;\n    &lt;mvc:interceptors&gt;<br>        &lt;mvc:interceptor&gt;<br>            &lt;mvc:mapping path=\"/**\"/&gt;<br>            &lt;bean&gt;<br>                &lt;constructor-arg&gt;<br>                    &lt;ref bean=\"resourceUrlProvider\"/&gt;<br>                &lt;/constructor-arg&gt;<br>            &lt;/bean&gt;<br>        &lt;/mvc:interceptor&gt;<br>    &lt;/mvc:interceptors&gt;</code></pre><p>web.xml</p><pre><code>&lt;!--加上这句监听Request--&gt;\n&lt;listener&gt;<br>&lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;<br>&lt;/listener&gt;</code></pre><p>重写EnterpriseCacheSessionDAO</p><p>redisSessionService就是sessionDao</p><pre><code><p>public class redisSessionService extends EnterpriseCacheSessionDAO {<br>\t  private static Logger logger =Logger.getLogger(redisSessionService.class);<br>\t private int expire;<br><br>\t RedisDb redisOP=new RedisDb();<br>\t    @Override<br>\t    protected Serializable doCreate(Session session) {<br>\t    \t<br>\t        Serializable sessionId = super.doCreate(session);<br>\t        redisOP.setObject(sessionId.toString().getBytes(), sessionToByte(session),expire);<br>\t        System.out.println(\"创建Session:\"+session);<br>\t        return sessionId;<br>\t    }<br><br>\t    // 获取session<br>\t    @Override<br>\t    public Session doReadSession(Serializable sessionId) {<br>\t        // 先从缓存中获取session，如果没有再去数据库中获取<br>\t        Session session = super.doReadSession(sessionId); <br>\t        HttpServletRequest request = Servlets.getRequest();<br>\t\t\tif (request != null){<br>\t\t\t\tString uri = request.getServletPath();<br>\t\t\t\t// 如果是静态文件，则不获取SESSION<br>\t\t\t\tif (Servlets.isStaticFile(uri)){<br>\t\t\t<br>\t\t\t\t\t//return (Session) request.getAttribute(\"shrio_session\");<br>\t\t\t\t\trequest.getSession();<br>\t\t\t\t}<br>\t\t<br>\t\t\t}<br><br>\t        if(session == null){<br>\t            byte[] bytes = redisOP.getObject(sessionId.toString().getBytes());<br>\t            System.out.println(\"读取bytes:\"+bytes);<br>\t            if(bytes != null &amp;&amp; bytes.length &gt; 0){<br>\t                session = byteToSession(bytes);    <br>\t              <br>\t            }<br>\t            else{<br>\t            \t<br>\t            }<br>\t           <br>\t        }<br>\t   <br>\t        return session;<br>\t    }<br><br>\t    // 更新session的最后一次访问时间<br>\t    @Override<br>\t    public void doUpdate(Session session) {<br>\t    \tHttpServletRequest request = Servlets.getRequest();<br>\t        if (session instanceof ShiroSession) {<br>\t    \t ShiroSession ss = (ShiroSession) session;<br>\t    \t  if (session instanceof ValidatingSession &amp;&amp; !((ValidatingSession) session).isValid()) {<br>\t                return;<br>\t            }<br>               if (!ss.isChanged()) {<br>                   return;<br>               }<br>\t    \tif (request != null){<br>\t    \t     String uri = request.getServletPath();<br>\t    \t     // 如果是静态文件，则不更新SESSION<br>\t    \t     if (Servlets.isStaticFile(uri)){<br>\t    \t         return;<br>\t    \t     }<br>\t    \t  <br>\t    \t}<br>\t        <br>\t        ss.setChanged(false);<br>\t        super.doUpdate(session);<br>\t        redisOP.setObject(session.getId().toString().getBytes(), sessionToByte(session),expire);<br>\t        System.out.println(\"更新Session:\"+session);<br>\t        }<br>\t        else{<br>\t        \t logger.error(\"更新Session失败\");<br>\t        }<br>\t    <br>\t    }<br><br>\t    // 删除session<br>\t    @Override<br>\t    protected void doDelete(Session session) {<br>\t        super.doDelete(session);<br>\t        redisOP.delString(session.getId() + \"\");<br>\t        System.out.println(\"删除Session:\"+session);<br>\t    }<br><br>\t    // 把session对象转化为byte保存到redis中<br>\t    public byte[] sessionToByte(Session session){<br>\t        ByteArrayOutputStream bo = new ByteArrayOutputStream();<br>\t        byte[] bytes = null;<br>\t        try {<br>\t            ObjectOutputStream oo = new ObjectOutputStream(bo);<br>\t            oo.writeObject(session);<br>\t            bytes = bo.toByteArray();<br>\t        } catch (IOException e) {<br>\t            e.printStackTrace();<br>\t        }<br>\t        return bytes;<br>\t    }<br>\t    <br>\t    // 把byte还原为session<br>\t    public Session byteToSession(byte[] bytes){<br>\t        ByteArrayInputStream bi = new ByteArrayInputStream(bytes);<br>\t        ObjectInputStream in;<br>\t        SimpleSession session = null;<br>\t        try {<br>\t            in = new ObjectInputStream(bi);<br>\t            session = (SimpleSession) in.readObject();<br>\t        } catch (ClassNotFoundException e) {<br>\t            e.printStackTrace();<br>\t        } catch (IOException e) {<br>\t            e.printStackTrace();<br>\t        }<br>\t    <br>\t        return session;<br>\t    }<br><br>\t\tpublic int getExpire() {<br>\t\t\treturn expire;<br>\t\t}<br><br>\t\tpublic void setExpire(int expire) {<br>\t\t\tthis.expire = expire;<br>\t\t}<br>\t    <br>}</p></code></pre><h1>Session和SessionFactory</h1><p>lastAccessTime意外其它字段修改，就标识一下。以达到上面防止多次更新Redis的问题，减少网络压力</p><p>ShiroSession</p><pre><code>public class ShiroSession extends SimpleSession implements Serializable {<br><br>\t/**<br>\t * <br>\t */<br>\tprivate static final long serialVersionUID = 1L;<br>\tprivate boolean isChanged;<br><br>    public ShiroSession() {<br>        super();<br>        this.setChanged(true);<br>    }<br><br>    public ShiroSession(String host) {<br>        super(host);<br>        this.setChanged(true);<br>    }<br><br><br>    @Override<br>    public void setId(Serializable id) {<br>        super.setId(id);<br>        this.setChanged(true);<br>    }<br><br>    @Override<br>    public void setStopTimestamp(Date stopTimestamp) {<br>        super.setStopTimestamp(stopTimestamp);<br>        this.setChanged(true);<br>    }<br><br>    @Override<br>    public void setExpired(boolean expired) {<br>        super.setExpired(expired);<br>        this.setChanged(true);<br>    }<br><br>    @Override<br>    public void setTimeout(long timeout) {<br>        super.setTimeout(timeout);<br>        this.setChanged(true);<br>    }<br><br>    @Override<br>    public void setHost(String host) {<br>        super.setHost(host);<br>        this.setChanged(true);<br>    }<br><br>    @Override<br>    public void setAttributes(Map&lt;Object, Object&gt; attributes) {<br>        super.setAttributes(attributes);<br>        this.setChanged(true);<br>    }<br><br>    @Override<br>    public void setAttribute(Object key, Object value) {<br>        super.setAttribute(key, value);<br>        this.setChanged(true);<br>    }<br><br>    @Override<br>    public Object removeAttribute(Object key) {<br>        this.setChanged(true);<br>        return super.removeAttribute(key);<br>    }<br><br>    /**<br>     * 停止<br>     */<br>    @Override<br>    public void stop() {<br>        super.stop();<br>        this.setChanged(true);<br>    }<br><br>    /**<br>     * 设置过期<br>     */<br>    @Override<br>    protected void expire() {<br>        this.stop();<br>        this.setExpired(true);<br>    }<br><br>    public boolean isChanged() {<br>        return isChanged;<br>    }<br><br>    public void setChanged(boolean isChanged) {<br>        this.isChanged = isChanged;<br>    }<br><br>    @Override<br>    public boolean equals(Object obj) {<br>        return super.equals(obj);<br>    }<br><br>    @Override<br>    protected boolean onEquals(SimpleSession ss) {<br>        return super.onEquals(ss);<br>    }<br><br>    @Override<br>    public int hashCode() {<br>        return super.hashCode();<br>    }<br><br>    @Override<br>    public String toString() {<br>        return super.toString();<br>    }<br>}</code></pre><p>ShiroSessionFactory</p><pre><code>public class ShiroSessionFactory implements SessionFactory{<br><br>\tpublic Session createSession(SessionContext initData) {<br>\t\t ShiroSession session = new ShiroSession();<br>\t        return session;<br>\t}<br><br>}</code></pre><p><br></p><p>然后一整套一下来就解决了</p><p>当然还有注意js对cookie的操作会使得系统崩溃。这个就留个悬念吧</p><p><img src=\"https://imgsa.baidu.com/forum/w%3D580/sign=b25f27e5933df8dca63d8f99fd1072bf/6e85c2177f3e67090bad6ced37c79f3df8dc5572.jpg\" size=\"5998\" width=\"170\" height=\"160\"></p><p><br></p><p><br></p>',1,'Beloya','2018-08-12 11:25:20','Beloya','2018-08-12 23:31:00',0,280,0,1),
  (33,'sss','<p>ssss</p>',1,'Beloya','2018-08-12 11:48:30',NULL,NULL,-1,0,0,2),
  (34,'ceshi1','<p>123456</p>',1,'Beloya','2018-08-14 00:05:44',NULL,NULL,-1,1,0,2),
  (35,'111111111111','<p>1</p>',1,'com.MyBlog.entity.Users@11541777','2018-08-27 04:10:08',NULL,NULL,-1,4,0,2);
COMMIT;

#
# Data for the `archivescommit` table  (LIMIT -438,500)
#

INSERT INTO `archivescommit` (`CID`, `Context`, `PID`, `REVISION`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`, `Status`, `AID`, `TYPE`, `Name`) VALUES

  (1,'<img src=\"../img/expression/face1.jpg\">',NULL,NULL,'Beloya','2018-07-09 14:15:23',NULL,NULL,0,9,0,NULL),
  (2,'',NULL,NULL,'Beloya','2018-07-09 14:35:02',NULL,NULL,0,9,0,NULL),
  (3,'',NULL,NULL,'Beloya','2018-07-09 14:35:55',NULL,NULL,0,9,0,NULL),
  (4,'',NULL,NULL,'Beloya','2018-07-09 14:36:03',NULL,NULL,0,9,0,NULL),
  (5,'(ฅ´ω`ฅ)',NULL,NULL,'Beloya','2018-07-09 14:36:12',NULL,NULL,0,9,0,NULL),
  (6,'(ฅ´ω`ฅ)<img src=\"../img/expression/face7.jpg\">',NULL,NULL,'Beloya','2018-07-09 14:38:53',NULL,NULL,0,9,0,NULL),
  (7,'',5,NULL,'Beloya','2018-07-09 15:11:48',NULL,NULL,0,9,0,NULL),
  (8,'',6,NULL,'Beloya','2018-07-09 15:11:54',NULL,NULL,0,9,0,NULL),
  (9,'|´・ω・)ノ',6,NULL,'Beloya','2018-07-09 15:12:28',NULL,NULL,0,9,0,NULL),
  (10,'',5,NULL,'Beloya','2018-07-09 15:13:30',NULL,NULL,0,9,0,NULL),
  (11,'',2,NULL,'Beloya','2018-07-09 15:19:06',NULL,NULL,0,9,0,NULL),
  (12,'',4,NULL,'Beloya','2018-07-09 15:19:14',NULL,NULL,0,9,0,NULL),
  (14,'( ,,´･ω･)ﾉ\"(´っω･｀｡)',NULL,NULL,'sa','2018-07-12 02:05:49',NULL,NULL,0,9,0,NULL),
  (15,'<img src=\"../img/emjoy/1.jpg\">',NULL,NULL,'sa','2018-07-12 03:44:45',NULL,NULL,0,9,0,NULL),
  (16,'( ๑´•ω•) \"(ㆆᴗㆆ)',NULL,NULL,'sa','2018-07-12 11:46:07',NULL,NULL,0,9,0,NULL),
  (17,'|´・ω・)ノ',NULL,NULL,'sa','2018-07-12 14:50:43',NULL,NULL,0,12,0,NULL),
  (18,'<img src=\"../img/emjoy/6.jpg\">',NULL,NULL,'sa','2018-07-12 17:23:33',NULL,NULL,0,1,0,NULL),
  (19,'|´・ω・)ノ',NULL,NULL,'sa','2018-07-12 17:44:57',NULL,NULL,0,1,0,NULL),
  (20,'∠( ᐛ 」∠)＿',NULL,NULL,'sa','2018-07-12 17:45:02',NULL,NULL,0,1,0,NULL),
  (21,'Hello',NULL,NULL,'游客','2018-07-13 10:24:29',NULL,NULL,0,10,1,'HelloWorld'),
  (22,'∠( ᐛ 」∠)＿',NULL,NULL,'游客','2018-07-13 11:46:26',NULL,NULL,0,10,0,'Beloya'),
  (23,'|´・ω・)ノ',NULL,NULL,'sa','2018-07-13 11:48:14',NULL,NULL,0,10,0,NULL),
  (24,'|´・ω・)ノ',NULL,NULL,'游客','2018-07-13 11:49:36',NULL,NULL,0,10,0,'<a style=\"color:red;\">Beloya</a>'),
  (25,'|´・ω・)ノ',NULL,NULL,'游客','2018-07-13 11:52:53',NULL,NULL,0,10,0,'<a href=\"www.baidu.com\" style=\"color:blue\">Hello</a>'),
  (26,'123',NULL,NULL,'游客','2018-07-13 11:55:07',NULL,NULL,0,10,0,'_Be'),
  (27,'|´・ω・)ノ',NULL,NULL,'游客','2018-07-13 12:02:09',NULL,NULL,0,10,0,'_aa'),
  (29,'321',NULL,NULL,'游客','2018-07-13 12:54:33',NULL,NULL,0,10,0,'123'),
  (30,'321',NULL,NULL,'游客','2018-07-13 12:54:37',NULL,NULL,0,10,0,'123'),
  (31,'321',NULL,NULL,'游客','2018-07-13 12:54:42',NULL,NULL,0,10,0,'aaaa'),
  (32,'123',NULL,NULL,'游客','2018-07-13 12:57:27',NULL,NULL,0,10,0,'ba'),
  (33,'321',NULL,NULL,'游客','2018-07-13 13:01:49',NULL,NULL,0,10,0,'as'),
  (34,'321',NULL,NULL,'游客','2018-07-13 13:04:32',NULL,NULL,0,10,0,'_sa'),
  (35,'321',NULL,NULL,'游客','2018-07-13 13:04:39',NULL,NULL,0,10,0,'_as'),
  (36,'<img src=\"../img/emjoy/4.jpg\">',NULL,NULL,'游客','2018-07-13 13:12:40',NULL,NULL,0,10,0,'sa'),
  (37,'1',NULL,NULL,'Demo','2018-07-14 16:47:42',NULL,NULL,0,16,0,NULL),
  (38,'2',NULL,NULL,'Demo','2018-07-14 16:47:52',NULL,NULL,0,16,0,NULL),
  (39,'୧(๑•̀⌄•́๑)૭',NULL,NULL,'Beloya','2018-07-14 21:46:15',NULL,NULL,0,16,0,NULL),
  (40,'(ฅ´ω`ฅ)',NULL,NULL,'游客','2018-07-15 01:37:52',NULL,NULL,0,1,0,'Beloya'),
  (41,'∠( ᐛ 」∠)＿',NULL,NULL,'游客','2018-07-15 01:48:21',NULL,NULL,0,17,0,'t'),
  (42,'牛皮<img src=\"../img/emjoy/3.jpg\">',NULL,NULL,'游客','2018-07-19 09:19:11',NULL,NULL,0,23,0,'2333'),
  (43,'<img src=\"../img/emjoy/3.jpg\">',NULL,NULL,'游客','2018-07-22 01:10:42',NULL,NULL,0,24,0,'233'),
  (49,'233',NULL,NULL,'游客','2018-07-22 05:49:44',NULL,NULL,0,25,0,'233'),
  (57,'(´இ皿இ｀)',NULL,NULL,'Beloya','2018-08-12 10:51:50',NULL,NULL,0,29,0,NULL),
  (58,'(ノ°ο°)ノ',NULL,NULL,'Beloya','2018-08-12 10:52:19',NULL,NULL,0,29,0,NULL),
  (59,'ヾ(≧∇≦*)ゝ',58,NULL,'Beloya','2018-08-12 10:52:45',NULL,NULL,0,29,0,NULL),
  (60,'<img src=\"../img/emjoy/5.jpg\">',58,NULL,'Beloya','2018-08-12 10:53:09',NULL,NULL,0,29,0,NULL),
  (61,'ヾ(≧∇≦*)ゝ',58,NULL,'Beloya','2018-08-12 10:55:37',NULL,NULL,0,29,0,NULL),
  (62,'<img src=\"../img/expression/jz2.gif\">',58,NULL,'Beloya','2018-08-12 10:59:07',NULL,NULL,0,29,0,NULL),
  (63,'<img src=\"../img/expression/jz5.jpg\">',57,NULL,'Beloya','2018-08-12 11:00:55',NULL,NULL,0,29,0,NULL),
  (64,'<img src=\"../img/expression/jz6.gif\">',57,NULL,'Beloya','2018-08-12 11:01:57',NULL,NULL,0,29,0,NULL),
  (65,'<img src=\"../img/expression/jz1.jpg\">',57,NULL,'Beloya','2018-08-12 11:03:56',NULL,NULL,0,29,0,NULL),
  (66,'⌇●﹏●⌇',57,NULL,'Beloya','2018-08-12 11:12:30',NULL,NULL,0,29,0,NULL),
  (67,'<img src=\"../img/emjoy/30.jpg\">',NULL,NULL,'Beloya','2018-08-12 18:25:58',NULL,NULL,0,32,0,NULL),
  (68,'<img src=\"../img/emjoy/8.jpg\">',67,NULL,'Beloya','2018-08-13 11:17:49',NULL,NULL,0,32,0,NULL),
  (69,'<img src=\"../img/expression/face3.jpg\">',NULL,NULL,'游客','2018-08-13 23:42:39',NULL,NULL,0,32,0,'as'),
  (70,'ヾ(≧∇≦*)ゝ',67,NULL,'游客','2018-08-14 08:22:54',NULL,NULL,0,32,2,'Beloya'),
  (71,'<img src=\"../img/emjoy/10.jpg\">',67,NULL,'游客','2018-08-14 08:23:18',NULL,NULL,0,32,2,'Beloya'),
  (72,'<img src=\"../img/expression/jz2.gif\">',67,NULL,'游客','2018-08-14 08:23:31',NULL,NULL,0,32,2,'Beloya1'),
  (73,'( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃',NULL,NULL,'游客','2018-08-14 08:23:41',NULL,NULL,0,32,0,'123456'),
  (74,'<img src=\"../img/expression/face2.gif\">',NULL,NULL,'Beloya','2018-08-14 08:24:33',NULL,NULL,0,32,0,NULL),
  (75,'12121',NULL,NULL,'游客','2018-08-16 20:22:05',NULL,NULL,0,28,0,'1212');
COMMIT;

#
# Data for the `archivesvisibility` table  (LIMIT -497,500)
#

INSERT INTO `archivesvisibility` (`ID`, `Vdescribe`, `REVISION`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`, `Status`) VALUES

  (1,'公开',NULL,'Beloya','2018-07-05 20:31:45',NULL,NULL,0),
  (2,'私有',NULL,'Beloya','2018-07-05 20:32:20',NULL,NULL,0);
COMMIT;

#
# Data for the `blog` table  (LIMIT -498,500)
#

INSERT INTO `blog` (`ID`, `BlogName`, `REVISION`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`, `Title`, `MessageSay`, `HeaderSkin`) VALUES

  (1,'Beloya',NULL,'Beloya','2018-07-02 21:35:32',NULL,NULL,'Hello World','\r\n<h3>有什么话想要吐槽的吗，你可以在这里咨询，可以交流，可以感叹，可以发飙<br/>\r\n不可以点外卖\r\n</h3>\r\n<p><img src=\"https://user-gold-cdn.xitu.io/2017/12/10/1603e7d16270426f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"\" data-action=\"zoom\"></p>','headerlogo.jpg');
COMMIT;

#
# Data for the `flag` table  (LIMIT -493,500)
#

INSERT INTO `flag` (`FID`, `Fdescribe`, `REVISION`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`, `Status`) VALUES

  (1,'原创',NULL,'Beloya','2018-07-06 21:13:58',NULL,NULL,0),
  (2,'分享',NULL,'Beloya','2018-07-06 21:14:18',NULL,NULL,0),
  (3,'转载',NULL,'Beloya','2018-07-06 21:14:33',NULL,NULL,0),
  (4,'趣闻',NULL,'Beloya','2018-07-16 02:54:01',NULL,NULL,0),
  (5,'心情',NULL,'Beloya','2018-07-16 02:55:16',NULL,NULL,0),
  (15,'设计模式',NULL,'Beloya','2018-07-22 03:00:21',NULL,NULL,0);
COMMIT;

#
# Data for the `message_board` table  (LIMIT -496,500)
#

INSERT INTO `message_board` (`MBID`, `Context`, `REVISION`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`, `Status`, `Name`, `MBPID`) VALUES

  (1,'٩(ˊᗜˋ*)و',NULL,'游客','2018-07-23 05:02:51',NULL,NULL,0,'233',NULL),
  (2,'<img src=\"../img/expression/face3.jpg\"> <js>var i=0;</js>',NULL,'游客','2018-07-23 08:17:23',NULL,NULL,0,'Hello World',NULL),
  (3,'<img src=\"../img/emjoy/2.jpg\" layer-index=\"2\">',NULL,'游客','2018-07-24 07:42:10',NULL,NULL,0,'233',NULL);
COMMIT;

#
# Data for the `roles` table  (LIMIT -495,500)
#

INSERT INTO `roles` (`R_Id`, `RoleName`, `description`, `CreatorId`, `CreateDate`, `DataLevel`) VALUES

  (1,'管理员','管理员',NULL,'2018-06-15 00:00:00',0),
  (2,'测试','测试角色',NULL,'2018-06-17 11:16:10',0),
  (3,'博主','博客创建者',NULL,'2018-07-05 22:55:08',0),
  (4,'观光团','观光团',NULL,'2018-07-05 22:55:08',0);
COMMIT;

#
# Data for the `roles_permissions` table  (LIMIT -490,500)
#

INSERT INTO `roles_permissions` (`RP_Id`, `RId`, `permission`, `CreatorId`, `CreateDate`, `DataLevel`) VALUES

  (1,1,'普通:文章:update',NULL,'2018-06-15 00:00:00',0),
  (2,1,'普通:文章:view',NULL,'2018-06-15 00:00:00',0),
  (3,1,'普通:文章:*',NULL,'2018-06-17 11:18:01',0),
  (4,1,'普通:文章:create',NULL,'2018-07-05 22:55:52',0),
  (5,1,'普通:评论:*',NULL,'2018-07-09 21:12:45',0),
  (7,3,'普通:评论:*',NULL,'2018-07-09 21:12:45',0),
  (8,3,'普通:文章:*',NULL,'2018-07-09 21:12:45',0),
  (9,3,'系统:监控:*',NULL,'2018-08-07 21:45:37',0),
  (10,1,'系统:监控:*',NULL,'2018-08-07 21:46:13',0);
COMMIT;

#
# Data for the `type` table  (LIMIT -493,500)
#

INSERT INTO `type` (`TID`, `Tdescribe`, `REVISION`, `CREATED_BY`, `CREATED_TIME`, `UPDATED_BY`, `UPDATED_TIME`, `Status`) VALUES

  (1,'分享',NULL,'System','2018-07-06 21:13:58','admin','2018-08-07 14:09:15',0),
  (2,'原创',NULL,'System','2018-07-06 21:13:58',NULL,NULL,0),
  (3,'杂记',NULL,'System','2018-07-06 21:13:58',NULL,NULL,0),
  (4,'心情',NULL,'System','2018-07-06 21:13:58',NULL,NULL,0),
  (5,'趣闻',NULL,'Beloya','2018-07-16 02:40:24',NULL,NULL,0),
  (10,'转载',NULL,'Beloya','2018-07-19 09:13:46',NULL,NULL,0);
COMMIT;

#
# Data for the `users` table  (LIMIT -493,500)
#

INSERT INTO `users` (`U_Id`, `Rid`, `userName`, `passWord`, `CreatorId`, `CreateDate`, `DataLevel`, `Email`, `Sex`, `locked`, `UserImg`) VALUES

  (1,3,'Beloya','2fe432cb14fa1c3b33ea6156669648ce',NULL,'2018-06-15 00:00:00',0,'468501955@qq.com',0,1,'/images/10.jpg'),
  (2,2,'test','test',NULL,'2018-06-17 11:16:38',0,NULL,0,1,'0'),
  (3,4,'sa','c4ca4238a0b923820dcc509a6f75849b',0,'2018-07-11 08:54:40',0,'123@qq.com',3,1,'/images/MyT.jpg'),
  (4,4,'Demo','e10adc3949ba59abbe56e057f20f883e',0,'2018-07-14 16:47:34',0,'Demo@qq.com',3,1,'/images/MyT.jpg'),
  (5,4,'beloya','2fe432cb14fa1c3b33ea6156669648ce',0,'2018-07-15 01:41:58',0,'123@qq.com',3,1,'/images/MyT.jpg'),
  (6,4,'1','c4ca4238a0b923820dcc509a6f75849b',0,'2018-08-24 01:53:15',0,'122281742@qq.com',3,1,'/images/MyT.jpg');
COMMIT;



/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;